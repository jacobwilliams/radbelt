var tipuesearch = {"pages":[{"title":" radbelt ","text":"radbelt Radbelt: Work in progress to refactor the AE-8/AP-8 Van Allen belt model. Status Compiling A Fortran Package Manager manifest file is included, so that the library and test cases can be compiled with FPM. For example: fpm build --profile release\nfpm test --profile release To use radbelt within your fpm project, add the following to your fpm.toml file: [dependencies] radbelt = { git = \"https://github.com/jacobwilliams/radbelt.git\" } Documentation The latest API documentation can be found here . This was generated from the source code using FORD . Original source The original sourcecode was hosted at GSFC \"Modelweb\", which no longer exists, but an archive can be found at the Internet Archive . It is presumed to be in the public domain. Reference: National Space Science Data Center, Data set PT-11B, Mar 1996. Dieter Bilitza, GSFC/NSSDC code 633, Greenbelt, MD 20771, tel. (301) 286-0190, dbilitza@pop600.gsfc.nasa.gov See also NASA ModelWebArchive An Astropy-friendly wrapper for the AE-8/AP-8 Van Allen belt model pyIGRF https://github.com/lanl/RAM-SCB/blob/master/srcExternal/igrf.f https://github.com/space-physics/igrf/blob/main/src/igrf/fortran/igrf13.f https://web.archive.org/web/20210318113325/https://ccmc.gsfc.nasa.gov/pub/modelweb/ Model parameters can be computed and plotted online at http://nssdc.gsfc.nasa.gov/space/model/ [broken link] Test case See the radbelt_test.f90 and test.py files: Code Runtime (sec) Cases per second Python version 3.514 409 Fortran Function version ( get_flux() ) 1.622 1198 Fortran Class version ( radbelt_type%get_flux() ) 0.017 112259 The main difference in speed from using the class method is that the data files are only read once, rather than each time the function is called (which is done in the other two versions). Brief description These empirical models describe the differential or\nintegral, omnidirectional fluxes of electrons (AE-8) and protons\n(AP-8) in the inner and outer radiation belts (electrons: L=1.1\nto 11, protons: L=1.1 to 7) for two epochs representing solar\nmaximum (1970) and minimum (1964) conditions. The energy spectrum\nranges from 0.1 to 400 MeV for the protons and from 0.04 to 7 MeV\nfor the electrons. AE-8 and AP-8 are the most recent ones in a\nseries of models established by J. Vette and his colleges at NSSDC\nstarting in the early sixties. The models are based on almost all\navailable satellite data. It is IMPORTANT that the models maps for\nsolar maximum are used with a magnetic field model for epoch=1970\nand for solar minimum for epoch=1964. For each epoch and particle the model consists of a three-\ndimensional table of (logarithm of) particle fluxes in energy, L-value,\nand B/B0 (magnetic field strength normalized to the equator). The program\nMODEL finds the particle fluxes for given energy, L-value and B/B0 by\ninterpolating in energy (subroutine TRARA1) and in L * B/B0 space (TRARA2).\nThe program RADBELT produces tables of integral or differential fluxes\nfor different energies varying with L or B/B0. The coefficient files are provided in ASCII (*.asc) format: Description Filename Size (KB) AE-8, epoch 1970, solar maximum ae8max.asc 84 AE-8, epoch 1964, solar minimum ae8min.asc 81 AP-8, epoch 1970, solar maximum ap8max.asc 101 AP-8, epoch 1964, solar minimum ap8min.asc 102 In March 1995 the earlier used compressed model maps AP8MIC and AP8MAC\nwere replaced with the full maps AP8MIN/MAX with the help of D. Heynderickx\n(BIRA, Brussel, Belgium) and A. Beliaev (INP/MSU, Moscow, Russia). Heynderickx\nand Beliaev (1995) had found and corrected a small error in the AP8MIN map;\ntwo lines had been exchanged. References G.W. Singley, and J.I. Vette, The AE-4 Model of the Outer Radiation\n  Zone Electron Environment, NSSDC/WDC-A-R&S 72-06, 1972. M.J. Teague, and J.I. Vette, A Model of the Trapped Electron\n  Population for Solar Minimum (AE-5), NSSDC/WDC-A-R&S 74-03, 1974. M.J. Teague, K.W. Chan, and J.I. Vette, AE-6: A Model Environment\n  of Trapped Electrons for Solar Maximum, NSSDC/WDC-A-R&S 76-04, 1976 D.W. Sawyer, and J.I. Vette, AP-8 Trapped Proton Environment for\n  Solar Maximum and Minimum, NSSDC/WDC-A-R&S 76-06, 1976. J.I. Vette, K.W. Chan, and M.J. Teague, Problems in Modeling the\n  Earth's Trapped Radiation Environment, AFGL-TR-78-0130, 1978. K.W. Chan, M.J. Teague, N.J. Schofield, and J.I. Vette, Modeling of\n  Electron Time Variation in the Radiation Belts, p. 121-149, in:\n  Quantitative Modeling of Magnetospheric Processes, W.P. Olson\n  (ed.), geophysical monograph 21, American Geophysical Union, 1979. M.T. Teague, N.J. Schofield, K.W. Chan, and J.I. Vette, A Study of\n  Inner Zone Electron Data and their Comparison with Trapped\n  Radiation Models, NSSDC/WDC-A-R&S 79-06, 1979. J.I. Vette, The AE-8 Trapped Electron Model Environment,\n  NSSDC/WDC-A-R&S 91-24, 1991. J.I. Vette, The NASA/National Space Science Data Center Trapped\n  Radiation Environment Model Program (1964-1991), NSSDC/WDC-A-R&S\n  91-29, 1991. D. Heynderickx and A. Beliaev, J. Spacecraft and Rockets 32, 190-192, 1995. Developer Info Jacob Williams","tags":"home","loc":"index.html"},{"title":"radbelt_type – radbelt ","text":"type, public :: radbelt_type the main class that can be used to get the flux. Inherits type~~radbelt_type~~InheritsGraph type~radbelt_type radbelt_type type~shellig_type shellig_type type~radbelt_type->type~shellig_type igrf type~trm_type trm_type type~radbelt_type->type~trm_type trm Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( trm_type ), private :: trm type( shellig_type ), private :: igrf Type-Bound Procedures procedure, public :: get_flux => get_flux_ public  function get_flux_ (me, lon, lat, height, year, e, imname) result(flux) Calculate the flux of trapped particles at a specific location and time. Arguments Type Intent Optional Attributes Name class( radbelt_type ), intent(inout) :: me real(kind=wp), intent(in) :: lon geodetic longitude in degrees (east) real(kind=wp), intent(in) :: lat geodetic latitude in degrees (north) real(kind=wp), intent(in) :: height altitude in km above sea level real(kind=wp), intent(in) :: year decimal year for which geomagnetic field is to\nbe calculated (e.g.:1995.5 for day 185 of 1995) real(kind=wp), intent(in) :: e minimum energy integer, intent(in) :: imname which method to use: Read more… Return Value real(kind=wp) The flux of particles above the given energy, in units of cm&#94;-2 s&#94;-1. procedure, public :: set_data_files_paths public  subroutine set_data_files_paths (me, aep8_dir, igrf_dir) Set the paths to the data files.\nIf not used or blank, the folder data/aep8 and data/igrf in the\ncurrent working directory is assumed Arguments Type Intent Optional Attributes Name class( radbelt_type ), intent(inout) :: me character(len=*), intent(in) :: aep8_dir character(len=*), intent(in) :: igrf_dir Source Code type , public :: radbelt_type !! the main class that can be used to get the flux. private type ( trm_type ) :: trm type ( shellig_type ) :: igrf contains private procedure , public :: get_flux => get_flux_ procedure , public :: set_data_files_paths end type radbelt_type","tags":"","loc":"type/radbelt_type.html"},{"title":"shellig_type – radbelt ","text":"type, public :: shellig_type Inherited by type~~shellig_type~~InheritedByGraph type~shellig_type shellig_type type~radbelt_type radbelt_type type~radbelt_type->type~shellig_type igrf Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: igrf_dir directory containing the data files real(kind=wp), private, dimension(3) :: sp = 0.0_wp real(kind=wp), private, dimension(3) :: xi = 0.0_wp real(kind=wp), private, dimension(144) :: h = 0.0_wp Field model coefficients adjusted for shellg integer, private :: iyea = 0 the int year corresponding to the file name that has been read character(len=:), private, allocatable :: name file name integer, private :: nmax = 0 maximum order of spherical harmonics real(kind=wp), private :: Time = 0.0_wp year (decimal: 1973.5) for which magnetic field is to be calculated real(kind=wp), private, dimension(144) :: g = 0.0_wp g(m) -- normalized field coefficients (see feldcof ) m=nmax*(nmax+2) integer, private :: nmax1 = 0 saved variables from the file integer, private :: nmax2 = 0 saved variables from the file real(kind=wp), private, dimension(144) :: g_cache = 0.0_wp saved g from the file real(kind=wp), private :: step = 0.20_wp step size for field line tracing real(kind=wp), private :: steq = 0.03_wp step size for integration real(kind=wp), private, dimension(120) :: gh2 = 0.0_wp Type-Bound Procedures procedure, public :: igrf private  subroutine igrf (me, lon, lat, height, year, xl, bbx) Wrapper for IGRF functions. Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me real(kind=wp), intent(in) :: lon geodetic longitude in degrees (east) real(kind=wp), intent(in) :: lat geodetic latitude in degrees (north) real(kind=wp), intent(in) :: height altitude in km above sea level real(kind=wp), intent(in) :: year decimal year for which geomagnetic field is to\nbe calculated (e.g.:1995.5 for day 185 of 1995) real(kind=wp), intent(out) :: xl l-value real(kind=wp), intent(out) :: bbx b_total / b_equatorial ratio procedure, public :: feldcof private  subroutine feldcof (me, year, dimo) Determines coefficients and dipol moment from IGRF models Read more… Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me real(kind=wp), intent(in) :: year decimal year for which geomagnetic field is to\nbe calculated (e.g.:1995.5 for day 185 of 1995) real(kind=wp), intent(out) :: dimo geomagnetic dipol moment in gauss (normalized\nto earth's radius) at the time (year) procedure, public :: feldg private  subroutine feldg (me, glat, glon, alt, bnorth, beast, bdown, Babs) Calculates earth magnetic field from spherical harmonics model Read more… Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me real(kind=wp), intent(in) :: glat geodetic latitude in degrees (north) real(kind=wp), intent(in) :: glon geodetic longitude in degrees (east) real(kind=wp), intent(in) :: alt altitude in km above sea level real(kind=wp), intent(out) :: bnorth components of the field with respect\nto the local geodetic coordinate system, with axis\npointing in the tangential plane to the north, east\nand downward. real(kind=wp), intent(out) :: beast components of the field with respect\nto the local geodetic coordinate system, with axis\npointing in the tangential plane to the north, east\nand downward. real(kind=wp), intent(out) :: bdown components of the field with respect\nto the local geodetic coordinate system, with axis\npointing in the tangential plane to the north, east\nand downward. real(kind=wp), intent(out) :: Babs magnetic field strength in gauss procedure, public :: shellg private  subroutine shellg (me, glat, glon, alt, dimo, fl, icode, b0) calculates l-value for specified geodaetic coordinates, altitude\n  and gemagnetic field model. Read more… Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me real(kind=wp), intent(in) :: glat GEODETIC LATITUDE IN DEGREES (NORTH) real(kind=wp), intent(in) :: glon GEODETIC LONGITUDE IN DEGREES (EAST) real(kind=wp), intent(in) :: alt ALTITUDE IN KM ABOVE SEA LEVEL real(kind=wp), intent(in) :: dimo DIPOL MOMENT IN GAUSS (NORMALIZED TO EARTH RADIUS) real(kind=wp), intent(out) :: fl l-value integer, intent(out) :: icode Read more… real(kind=wp), intent(out) :: b0 magnetic field strength in gauss procedure, public :: findb0 private  subroutine findb0 (me, stps, bdel, value, bequ, rr0) Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me real(kind=wp), intent(in) :: stps real(kind=wp), intent(inout) :: bdel logical, intent(out) :: value real(kind=wp), intent(out) :: bequ real(kind=wp), intent(out) :: rr0 procedure, private :: extrashc private  subroutine extrashc (me, date, dte1, nmax1, gh1, nmax2, gh2, nmax, gh) Extrapolates linearly a spherical harmonic model with a\n  rate-of-change model. Read more… Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me real(kind=wp), intent(in) :: date Date of resulting model (in decimal year) real(kind=wp), intent(in) :: dte1 Date of base model integer, intent(in) :: nmax1 Maximum degree and order of base model real(kind=wp), intent(in) :: gh1 (*) Schmidt quasi-normal internal spherical harmonic coefficients of base model integer, intent(in) :: nmax2 Maximum degree and order of rate-of-change model real(kind=wp), intent(in) :: gh2 (*) Schmidt quasi-normal internal spherical harmonic coefficients of rate-of-change model integer, intent(out) :: nmax Maximum degree and order of resulting model real(kind=wp), intent(out) :: gh (*) Coefficients of resulting model procedure, private :: intershc private  subroutine intershc (me, date, dte1, nmax1, gh1, dte2, nmax2, gh2, nmax, gh) Interpolates linearly, in time, between two spherical\n  harmonic models. Read more… Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me real(kind=wp), intent(in) :: date Date of resulting model (in decimal year) real(kind=wp), intent(in) :: dte1 Date of earlier model integer, intent(in) :: nmax1 Maximum degree and order of earlier model real(kind=wp), intent(in) :: gh1 (*) Schmidt quasi-normal internal spherical harmonic coefficients of earlier model real(kind=wp), intent(in) :: dte2 Date of later model integer, intent(in) :: nmax2 Maximum degree and order of later model real(kind=wp), intent(in) :: gh2 (*) Schmidt quasi-normal internal spherical harmonic coefficients of later model integer, intent(out) :: nmax Maximum degree and order of resulting model real(kind=wp), intent(out) :: gh (*) Coefficients of resulting model procedure, private :: getshc private  subroutine getshc (me, Fspec, Nmax, Erad, Gh, Ier) Reads spherical harmonic coefficients from the specified\n  file into an array. Read more… Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me character(len=*), intent(in) :: Fspec File specification integer, intent(out) :: Nmax Maximum degree and order of model real(kind=wp), intent(out) :: Erad Earth's radius associated with the spherical\nharmonic coefficients, in the same units as\nelevation real(kind=wp), intent(out), dimension(*) :: Gh Schmidt quasi-normal internal spherical\nharmonic coefficients integer, intent(out) :: Ier Error number: Read more… procedure, private :: stoer private  subroutine stoer (me, p, bq, r) subroutine used for field line tracing in shellg calls entry point feldi in geomagnetic field subroutine feldg Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me real(kind=wp), intent(inout), dimension(7) :: p real(kind=wp), intent(out) :: bq real(kind=wp), intent(out) :: r procedure, public :: get_data_file_dir private  function get_data_file_dir (me) result(dir) Get the directory containing the data files. Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(in) :: me Return Value character(len=:), allocatable procedure, public :: set_data_file_dir private  subroutine set_data_file_dir (me, dir) Set the directory containing the data files. Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me character(len=*), intent(in) :: dir Source Code type , public :: shellig_type private character ( len = :), allocatable :: igrf_dir !! directory containing the data files ! formerly in the `fidb0` common block real ( wp ), dimension ( 3 ) :: sp = 0.0_wp ! formerly in blank common real ( wp ), dimension ( 3 ) :: xi = 0.0_wp real ( wp ), dimension ( 144 ) :: h = 0.0_wp !! Field model coefficients adjusted for [[shellg]] ! formerly in `model` common block integer :: iyea = 0 !! the int year corresponding to the file `name` that has been read character ( len = :), allocatable :: name !! file name integer :: nmax = 0 !! maximum order of spherical harmonics real ( wp ) :: Time = 0.0_wp !! year (decimal: 1973.5) for which magnetic field is to be calculated real ( wp ), dimension ( 144 ) :: g = 0.0_wp !! `g(m)` -- normalized field coefficients (see [[feldcof]]) m=nmax*(nmax+2) integer :: nmax1 = 0 !! saved variables from the file integer :: nmax2 = 0 !! saved variables from the file real ( wp ), dimension ( 144 ) :: g_cache = 0.0_wp !! saved `g` from the file ! formerly saved vars in shellg: real ( wp ) :: step = 0.20_wp !! step size for field line tracing real ( wp ) :: steq = 0.03_wp !! step size for integration ! from feldcof, so we can cache the coefficients real ( wp ), dimension ( 120 ) :: gh2 = 0.0_wp ! JW : why is this 120 and g is 144 ??? contains private procedure , public :: igrf procedure , public :: feldcof procedure , public :: feldg procedure , public :: shellg procedure , public :: findb0 procedure :: stoer , getshc , intershc , extrashc procedure , public :: set_data_file_dir , get_data_file_dir end type shellig_type","tags":"","loc":"type/shellig_type.html"},{"title":"trm_type – radbelt ","text":"type, public :: trm_type main class for the aep8 model Inherited by type~~trm_type~~InheritedByGraph type~trm_type trm_type type~radbelt_type radbelt_type type~radbelt_type->type~trm_type trm Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: aep8_dir directory containing the data files character(len=:), private, allocatable :: file_loaded the file that has been loaded integer, private, dimension(8) :: ihead = 0 integer, private, dimension(:), allocatable :: map real(kind=wp), private :: fistep = 0.0_wp the stepsize for the parameterization of the logarithm of flux.\nformerly stored in common block tra2 real(kind=wp), private :: f1 = 1.001_wp real(kind=wp), private :: f2 = 1.002_wp Type-Bound Procedures procedure, public :: aep8 main routine private  subroutine aep8 (me, e, l, bb0, imname, flux) Main wrapper for the radiation model.\nReads the coefficient file and calls the low-level routine. Arguments Type Intent Optional Attributes Name class( trm_type ), intent(inout) :: me real(kind=wp), intent(in) :: e real(kind=wp), intent(in) :: l real(kind=wp), intent(in) :: bb0 integer, intent(in) :: imname which model to load (index in mname array) real(kind=wp), intent(out) :: flux procedure, public :: trara2 low-level routine private  function trara2 (me, map, il, ib) trara2 interpolates linearly in l-b/b0-map to obtain\n  the logarithm of integral flux at given l and b/b0. Read more… Arguments Type Intent Optional Attributes Name class( trm_type ), intent(inout) :: me integer, intent(in) :: map (*) is sub-map (for specific energy) of\ntrapped radiation model map integer, intent(in) :: il scaled l-value integer, intent(in) :: ib scaled b/b0-1 Return Value real(kind=wp) scaled logarithm of particle flux procedure, public :: trara1 private  subroutine trara1 (me, descr, map, fl, bb0, e, f, n) trara1 finds particle fluxes for given energies, magnetic field\nstrength and l-value. function trara2 is used to interpolate in\nb-l-space. Arguments Type Intent Optional Attributes Name class( trm_type ), intent(inout) :: me integer, intent(in) :: descr (8) header of specified trapped radition model integer, intent(in) :: map (*) map of trapped radition model\n(descr and map are explained at the begin\nof the main program model) real(kind=wp), intent(in) :: fl l-value real(kind=wp), intent(in) :: bb0 =b/b0  magnetic field strength normalized\nto field strength at magnetic equator real(kind=wp), intent(in) :: e (n) array of energies in mev real(kind=wp), intent(out) :: f (n) decadic logarithm of integral fluxes in\nparticles/(cm cm sec) integer, intent(in) :: n number of energies procedure, public :: get_data_file_dir private  function get_data_file_dir (me) result(dir) Get the directory containing the data files. Arguments Type Intent Optional Attributes Name class( trm_type ), intent(in) :: me Return Value character(len=:), allocatable procedure, public :: set_data_file_dir private  subroutine set_data_file_dir (me, dir) Set the directory containing the data files. Arguments Type Intent Optional Attributes Name class( trm_type ), intent(inout) :: me character(len=*), intent(in) :: dir Source Code type , public :: trm_type !! main class for the `aep8` model private character ( len = :), allocatable :: aep8_dir !! directory containing the data files ! data read from the files: character ( len = :), allocatable :: file_loaded !! the file that has been loaded integer , dimension ( 8 ) :: ihead = 0 integer , dimension (:), allocatable :: map real ( wp ) :: fistep = 0.0_wp !! the stepsize for the parameterization of the logarithm of flux. !! formerly stored in common block `tra2` ! formerly saved variables in trara1: real ( wp ) :: f1 = 1.001_wp real ( wp ) :: f2 = 1.002_wp contains private procedure , public :: aep8 !! main routine procedure , public :: trara1 , trara2 !! low-level routine procedure , public :: set_data_file_dir , get_data_file_dir end type trm_type","tags":"","loc":"type/trm_type.html"},{"title":"get_flux_ – radbelt","text":"public  function get_flux_(me, lon, lat, height, year, e, imname) result(flux) Calculate the flux of trapped particles at a specific location and time. Type Bound radbelt_type Arguments Type Intent Optional Attributes Name class( radbelt_type ), intent(inout) :: me real(kind=wp), intent(in) :: lon geodetic longitude in degrees (east) real(kind=wp), intent(in) :: lat geodetic latitude in degrees (north) real(kind=wp), intent(in) :: height altitude in km above sea level real(kind=wp), intent(in) :: year decimal year for which geomagnetic field is to\nbe calculated (e.g.:1995.5 for day 185 of 1995) real(kind=wp), intent(in) :: e minimum energy integer, intent(in) :: imname which method to use: 1 -- particle species: electrons, solar activity: min 2 -- particle species: electrons, solar activity: max 3 -- particle species: protons, solar activity: min 4 -- particle species: protons, solar activity: max Return Value real(kind=wp) The flux of particles above the given energy, in units of cm&#94;-2 s&#94;-1. Calls proc~~get_flux_~~CallsGraph proc~get_flux_ core::radbelt_type%get_flux_ proc~aep8 trmfun_module::trm_type%aep8 proc~get_flux_->proc~aep8 proc~igrf shellig_module::shellig_type%igrf proc~get_flux_->proc~igrf proc~get_data_file_dir~2 trmfun_module::trm_type%get_data_file_dir proc~aep8->proc~get_data_file_dir~2 proc~trara1 trmfun_module::trm_type%trara1 proc~aep8->proc~trara1 proc~feldcof shellig_module::shellig_type%feldcof proc~igrf->proc~feldcof proc~feldg shellig_module::shellig_type%feldg proc~igrf->proc~feldg proc~findb0 shellig_module::shellig_type%findb0 proc~igrf->proc~findb0 proc~shellg shellig_module::shellig_type%shellg proc~igrf->proc~shellg proc~extrashc shellig_module::shellig_type%extrashc proc~feldcof->proc~extrashc proc~get_data_file_dir shellig_module::shellig_type%get_data_file_dir proc~feldcof->proc~get_data_file_dir proc~getshc shellig_module::shellig_type%getshc proc~feldcof->proc~getshc proc~intershc shellig_module::shellig_type%intershc proc~feldcof->proc~intershc feldc feldc proc~feldg->feldc feldi feldi proc~feldg->feldi proc~stoer shellig_module::shellig_type%stoer proc~findb0->proc~stoer proc~shellg->proc~stoer shellc shellc proc~shellg->shellc proc~trara2 trmfun_module::trm_type%trara2 proc~trara1->proc~trara2 proc~stoer->feldi Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_flux_~~CalledByGraph proc~get_flux_ core::radbelt_type%get_flux_ proc~get_flux core::get_flux proc~get_flux->proc~get_flux_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function get_flux_ ( me , lon , lat , height , year , e , imname ) result ( flux ) class ( radbelt_type ), intent ( inout ) :: me real ( wp ), intent ( in ) :: lon !! geodetic longitude in degrees (east) real ( wp ), intent ( in ) :: lat !! geodetic latitude in degrees (north) real ( wp ), intent ( in ) :: height !! altitude in km above sea level real ( wp ), intent ( in ) :: year !! decimal year for which geomagnetic field is to !! be calculated (e.g.:1995.5 for day 185 of 1995) real ( wp ), intent ( in ) :: e !! minimum energy integer , intent ( in ) :: imname !! which method to use: !! !! * 1 -- particle species: electrons, solar activity: min !! * 2 -- particle species: electrons, solar activity: max !! * 3 -- particle species: protons, solar activity: min !! * 4 -- particle species: protons, solar activity: max real ( wp ) :: flux !! The flux of particles above the given energy, in units of cm&#94;-2 s&#94;-1. real ( wp ) :: xl !! l value real ( wp ) :: bbx call me % igrf % igrf ( lon , lat , height , year , xl , bbx ) call me % trm % aep8 ( e , xl , bbx , imname , flux ) end function get_flux_","tags":"","loc":"proc/get_flux_.html"},{"title":"get_flux – radbelt","text":"public  function get_flux(lon, lat, height, year, e, imname) result(flux) Calculate the flux of trapped particles at a specific location and time.\n  This is just a function version of the class method from radbelt_type . Note This routine is not efficient at all since it will reload all the\n      files every time it is called. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: lon geodetic longitude in degrees (east) real(kind=wp), intent(in) :: lat geodetic latitude in degrees (north) real(kind=wp), intent(in) :: height altitude in km above sea level real(kind=wp), intent(in) :: year decimal year for which geomagnetic field is to\nbe calculated (e.g.:1995.5 for day 185 of 1995) real(kind=wp), intent(in) :: e minimum energy integer, intent(in) :: imname which method to use: 1 -- particle species: electrons, solar activity: min 2 -- particle species: electrons, solar activity: max 3 -- particle species: protons, solar activity: min 4 -- particle species: protons, solar activity: max Return Value real(kind=wp) The flux of particles above the given energy, in units of cm&#94;-2 s&#94;-1. Calls proc~~get_flux~~CallsGraph proc~get_flux core::get_flux proc~get_flux_ core::radbelt_type%get_flux_ proc~get_flux->proc~get_flux_ proc~aep8 trmfun_module::trm_type%aep8 proc~get_flux_->proc~aep8 proc~igrf shellig_module::shellig_type%igrf proc~get_flux_->proc~igrf proc~get_data_file_dir~2 trmfun_module::trm_type%get_data_file_dir proc~aep8->proc~get_data_file_dir~2 proc~trara1 trmfun_module::trm_type%trara1 proc~aep8->proc~trara1 proc~feldcof shellig_module::shellig_type%feldcof proc~igrf->proc~feldcof proc~feldg shellig_module::shellig_type%feldg proc~igrf->proc~feldg proc~findb0 shellig_module::shellig_type%findb0 proc~igrf->proc~findb0 proc~shellg shellig_module::shellig_type%shellg proc~igrf->proc~shellg proc~extrashc shellig_module::shellig_type%extrashc proc~feldcof->proc~extrashc proc~get_data_file_dir shellig_module::shellig_type%get_data_file_dir proc~feldcof->proc~get_data_file_dir proc~getshc shellig_module::shellig_type%getshc proc~feldcof->proc~getshc proc~intershc shellig_module::shellig_type%intershc proc~feldcof->proc~intershc feldc feldc proc~feldg->feldc feldi feldi proc~feldg->feldi proc~stoer shellig_module::shellig_type%stoer proc~findb0->proc~stoer proc~shellg->proc~stoer shellc shellc proc~shellg->shellc proc~trara2 trmfun_module::trm_type%trara2 proc~trara1->proc~trara2 proc~stoer->feldi Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function get_flux ( lon , lat , height , year , e , imname ) result ( flux ) real ( wp ), intent ( in ) :: lon !! geodetic longitude in degrees (east) real ( wp ), intent ( in ) :: lat !! geodetic latitude in degrees (north) real ( wp ), intent ( in ) :: height !! altitude in km above sea level real ( wp ), intent ( in ) :: year !! decimal year for which geomagnetic field is to !! be calculated (e.g.:1995.5 for day 185 of 1995) real ( wp ), intent ( in ) :: e !! minimum energy integer , intent ( in ) :: imname !! which method to use: !! !! * 1 -- particle species: electrons, solar activity: min !! * 2 -- particle species: electrons, solar activity: max !! * 3 -- particle species: protons, solar activity: min !! * 4 -- particle species: protons, solar activity: max real ( wp ) :: flux !! The flux of particles above the given energy, in units of cm&#94;-2 s&#94;-1. type ( radbelt_type ) :: radbelt flux = radbelt % get_flux ( lon , lat , height , year , e , imname ) end function get_flux","tags":"","loc":"proc/get_flux.html"},{"title":"set_data_files_paths – radbelt","text":"public  subroutine set_data_files_paths(me, aep8_dir, igrf_dir) Set the paths to the data files.\nIf not used or blank, the folder data/aep8 and data/igrf in the\ncurrent working directory is assumed Type Bound radbelt_type Arguments Type Intent Optional Attributes Name class( radbelt_type ), intent(inout) :: me character(len=*), intent(in) :: aep8_dir character(len=*), intent(in) :: igrf_dir Calls proc~~set_data_files_paths~~CallsGraph proc~set_data_files_paths core::radbelt_type%set_data_files_paths proc~set_data_file_dir~2 trmfun_module::trm_type%set_data_file_dir proc~set_data_files_paths->proc~set_data_file_dir~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_data_files_paths ( me , aep8_dir , igrf_dir ) class ( radbelt_type ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: aep8_dir character ( len =* ), intent ( in ) :: igrf_dir call me % trm % set_data_file_dir ( trim ( aep8_dir )) call me % igrf % set_data_file_dir ( trim ( igrf_dir )) end subroutine set_data_files_paths","tags":"","loc":"proc/set_data_files_paths.html"},{"title":"get_data_file_dir – radbelt","text":"private  function get_data_file_dir(me) result(dir) Get the directory containing the data files. Type Bound shellig_type Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(in) :: me Return Value character(len=:), allocatable Called by proc~~get_data_file_dir~~CalledByGraph proc~get_data_file_dir shellig_module::shellig_type%get_data_file_dir proc~feldcof shellig_module::shellig_type%feldcof proc~feldcof->proc~get_data_file_dir proc~igrf shellig_module::shellig_type%igrf proc~igrf->proc~feldcof proc~get_flux_ core::radbelt_type%get_flux_ proc~get_flux_->proc~igrf proc~get_flux core::get_flux proc~get_flux->proc~get_flux_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function get_data_file_dir ( me ) result ( dir ) class ( shellig_type ), intent ( in ) :: me character ( len = :), allocatable :: dir if ( allocated ( me % igrf_dir )) then dir = trim ( me % igrf_dir ) // '/' else dir = 'data/igrf/' ! default end if end function get_data_file_dir","tags":"","loc":"proc/get_data_file_dir.html"},{"title":"set_data_file_dir – radbelt","text":"private  subroutine set_data_file_dir(me, dir) Set the directory containing the data files. Type Bound shellig_type Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me character(len=*), intent(in) :: dir Source Code subroutine set_data_file_dir ( me , dir ) class ( shellig_type ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: dir me % igrf_dir = trim ( dir ) end subroutine set_data_file_dir","tags":"","loc":"proc/set_data_file_dir.html"},{"title":"igrf – radbelt","text":"private  subroutine igrf(me, lon, lat, height, year, xl, bbx) Wrapper for IGRF functions. Type Bound shellig_type Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me real(kind=wp), intent(in) :: lon geodetic longitude in degrees (east) real(kind=wp), intent(in) :: lat geodetic latitude in degrees (north) real(kind=wp), intent(in) :: height altitude in km above sea level real(kind=wp), intent(in) :: year decimal year for which geomagnetic field is to\nbe calculated (e.g.:1995.5 for day 185 of 1995) real(kind=wp), intent(out) :: xl l-value real(kind=wp), intent(out) :: bbx b_total / b_equatorial ratio Calls proc~~igrf~~CallsGraph proc~igrf shellig_module::shellig_type%igrf proc~feldcof shellig_module::shellig_type%feldcof proc~igrf->proc~feldcof proc~feldg shellig_module::shellig_type%feldg proc~igrf->proc~feldg proc~findb0 shellig_module::shellig_type%findb0 proc~igrf->proc~findb0 proc~shellg shellig_module::shellig_type%shellg proc~igrf->proc~shellg proc~extrashc shellig_module::shellig_type%extrashc proc~feldcof->proc~extrashc proc~get_data_file_dir shellig_module::shellig_type%get_data_file_dir proc~feldcof->proc~get_data_file_dir proc~getshc shellig_module::shellig_type%getshc proc~feldcof->proc~getshc proc~intershc shellig_module::shellig_type%intershc proc~feldcof->proc~intershc feldc feldc proc~feldg->feldc feldi feldi proc~feldg->feldi proc~stoer shellig_module::shellig_type%stoer proc~findb0->proc~stoer proc~shellg->proc~stoer shellc shellc proc~shellg->shellc proc~stoer->feldi Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~igrf~~CalledByGraph proc~igrf shellig_module::shellig_type%igrf proc~get_flux_ core::radbelt_type%get_flux_ proc~get_flux_->proc~igrf proc~get_flux core::get_flux proc~get_flux->proc~get_flux_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine igrf ( me , lon , lat , height , year , xl , bbx ) class ( shellig_type ), intent ( inout ) :: me real ( wp ), intent ( in ) :: lon !! geodetic longitude in degrees (east) real ( wp ), intent ( in ) :: lat !! geodetic latitude in degrees (north) real ( wp ), intent ( in ) :: height !! altitude in km above sea level real ( wp ), intent ( in ) :: year !! decimal year for which geomagnetic field is to !! be calculated (e.g.:1995.5 for day 185 of 1995) real ( wp ), intent ( out ) :: xl !! l-value real ( wp ), intent ( out ) :: bbx !! b_total / b_equatorial ratio real ( wp ) :: bab1 , babs , bdel , bdown , beast , & beq , bequ , bnorth , dimo , rr0 integer :: icode logical :: val real ( wp ), parameter :: stps = 0.05_wp ! JW : do we need to reset some or all of these ? me % sp = 0.0_wp me % xi = 0.0_wp me % h = 0.0_wp me % step = 0.20_wp me % steq = 0.03_wp call me % feldcof ( year , dimo ) call me % feldg ( lat , lon , height , bnorth , beast , bdown , babs ) call me % shellg ( lat , lon , height , dimo , xl , icode , bab1 ) bequ = dimo / ( xl * xl * xl ) if ( icode == 1 ) then bdel = 1.0e-3_wp call me % findb0 ( stps , bdel , val , beq , rr0 ) if ( val ) bequ = beq endif bbx = babs / bequ end subroutine igrf","tags":"","loc":"proc/igrf.html"},{"title":"findb0 – radbelt","text":"private  subroutine findb0(me, stps, bdel, value, bequ, rr0) Type Bound shellig_type Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me real(kind=wp), intent(in) :: stps real(kind=wp), intent(inout) :: bdel logical, intent(out) :: value real(kind=wp), intent(out) :: bequ real(kind=wp), intent(out) :: rr0 Calls proc~~findb0~~CallsGraph proc~findb0 shellig_module::shellig_type%findb0 proc~stoer shellig_module::shellig_type%stoer proc~findb0->proc~stoer feldi feldi proc~stoer->feldi Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~findb0~~CalledByGraph proc~findb0 shellig_module::shellig_type%findb0 proc~igrf shellig_module::shellig_type%igrf proc~igrf->proc~findb0 proc~get_flux_ core::radbelt_type%get_flux_ proc~get_flux_->proc~igrf proc~get_flux core::get_flux proc~get_flux->proc~get_flux_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine findb0 ( me , stps , bdel , value , bequ , rr0 ) class ( shellig_type ), intent ( inout ) :: me real ( wp ), intent ( in ) :: stps real ( wp ), intent ( inout ) :: bdel real ( wp ), intent ( out ) :: bequ logical , intent ( out ) :: value real ( wp ), intent ( out ) :: rr0 real ( wp ) :: b , bdelta , bmin , bold , bq1 , & bq2 , bq3 , p ( 8 , 4 ) , r1 , r2 , r3 , & rold , step , step12 , zz integer :: i , irun , j , n step = stps irun = 0 main : do irun = irun + 1 if ( irun > 5 ) then value = . false . exit main endif !*********************first three points p ( 1 , 2 ) = me % sp ( 1 ) p ( 2 , 2 ) = me % sp ( 2 ) p ( 3 , 2 ) = me % sp ( 3 ) step =- sign ( step , p ( 3 , 2 )) call me % stoer ( p ( 1 , 2 ), bq2 , r2 ) p ( 1 , 3 ) = p ( 1 , 2 ) + 0.5_wp * step * p ( 4 , 2 ) p ( 2 , 3 ) = p ( 2 , 2 ) + 0.5_wp * step * p ( 5 , 2 ) p ( 3 , 3 ) = p ( 3 , 2 ) + 0.5_wp * step call me % stoer ( p ( 1 , 3 ), bq3 , r3 ) p ( 1 , 1 ) = p ( 1 , 2 ) - step * ( 2.0_wp * p ( 4 , 2 ) - p ( 4 , 3 )) p ( 2 , 1 ) = p ( 2 , 2 ) - step * ( 2.0_wp * p ( 5 , 2 ) - p ( 5 , 3 )) p ( 3 , 1 ) = p ( 3 , 2 ) - step call me % stoer ( p ( 1 , 1 ), bq1 , r1 ) p ( 1 , 3 ) = p ( 1 , 2 ) + step * ( 2 0.0_wp * p ( 4 , 3 ) - 3. * p ( 4 , 2 ) + p ( 4 , 1 )) / 1 8.0_wp p ( 2 , 3 ) = p ( 2 , 2 ) + step * ( 2 0.0_wp * p ( 5 , 3 ) - 3. * p ( 5 , 2 ) + p ( 5 , 1 )) / 1 8.0_wp p ( 3 , 3 ) = p ( 3 , 2 ) + step call me % stoer ( p ( 1 , 3 ), bq3 , r3 ) !******************invert sense if required if ( bq3 > bq1 ) then step =- step r3 = r1 bq3 = bq1 do i = 1 , 5 zz = p ( i , 1 ) p ( i , 1 ) = p ( i , 3 ) p ( i , 3 ) = zz end do end if !******************initialization step12 = step / 1 2.0_wp value = . true . bmin = 1.0e4_wp bold = 1.0e4_wp !******************corrector (field line tracing) n = 0 corrector : do p ( 1 , 3 ) = p ( 1 , 2 ) + step12 * ( 5.0_wp * p ( 4 , 3 ) + 8.0_wp * p ( 4 , 2 ) - p ( 4 , 1 )) n = n + 1 p ( 2 , 3 ) = p ( 2 , 2 ) + step12 * ( 5.0_wp * p ( 5 , 3 ) + 8.0_wp * p ( 5 , 2 ) - p ( 5 , 1 )) !******************predictor (field line tracing) p ( 1 , 4 ) = p ( 1 , 3 ) + step12 * ( 2 3.0_wp * p ( 4 , 3 ) - 1 6.0_wp * p ( 4 , 2 ) + 5.0_wp * p ( 4 , 1 )) p ( 2 , 4 ) = p ( 2 , 3 ) + step12 * ( 2 3.0_wp * p ( 5 , 3 ) - 1 6.0_wp * p ( 5 , 2 ) + 5.0_wp * p ( 5 , 1 )) p ( 3 , 4 ) = p ( 3 , 3 ) + step call me % stoer ( p ( 1 , 4 ), bq3 , r3 ) do j = 1 , 3 do i = 1 , 8 p ( i , j ) = p ( i , j + 1 ) end do end do b = sqrt ( bq3 ) if ( b < bmin ) bmin = b if ( b > bold ) exit corrector bold = b rold = 1.0_wp / r3 me % sp ( 1 ) = p ( 1 , 4 ) me % sp ( 2 ) = p ( 2 , 4 ) me % sp ( 3 ) = p ( 3 , 4 ) end do corrector if ( bold /= bmin ) value = . false . bdelta = ( b - bold ) / bold if ( bdelta <= bdel ) exit main step = step / 1 0.0_wp end do main rr0 = rold bequ = bold bdel = bdelta end subroutine findb0","tags":"","loc":"proc/findb0.html"},{"title":"shellg – radbelt","text":"private  subroutine shellg(me, glat, glon, alt, dimo, fl, icode, b0) calculates l-value for specified geodaetic coordinates, altitude\n  and gemagnetic field model. Reference G. KLUGE, EUROPEAN SPACE OPERATIONS CENTER, INTERNAL NOTE\n    NO. 67, 1970. G. KLUGE, COMPUTER PHYSICS COMMUNICATIONS 3, 31-35, 1972 History CHANGES (D. BILITZA, NOV 87): USING CORRECT DIPOL MOMENT I.E.,DIFFERENT COMMON/MODEL/ USING IGRF EARTH MAGNETIC FIELD MODELS FROM 1945 TO 1990 Type Bound shellig_type Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me real(kind=wp), intent(in) :: glat GEODETIC LATITUDE IN DEGREES (NORTH) real(kind=wp), intent(in) :: glon GEODETIC LONGITUDE IN DEGREES (EAST) real(kind=wp), intent(in) :: alt ALTITUDE IN KM ABOVE SEA LEVEL real(kind=wp), intent(in) :: dimo DIPOL MOMENT IN GAUSS (NORMALIZED TO EARTH RADIUS) real(kind=wp), intent(out) :: fl l-value integer, intent(out) :: icode =1 normal completion =2 unphysical conjugate point (fl meaningless) =3 shell parameter greater than limit up to\n  which accurate calculation is required;\n  approximation is used. real(kind=wp), intent(out) :: b0 magnetic field strength in gauss Calls proc~~shellg~~CallsGraph proc~shellg shellig_module::shellig_type%shellg proc~stoer shellig_module::shellig_type%stoer proc~shellg->proc~stoer shellc shellc proc~shellg->shellc feldi feldi proc~stoer->feldi Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~shellg~~CalledByGraph proc~shellg shellig_module::shellig_type%shellg proc~igrf shellig_module::shellig_type%igrf proc~igrf->proc~shellg proc~get_flux_ core::radbelt_type%get_flux_ proc~get_flux_->proc~igrf proc~get_flux core::get_flux proc~get_flux->proc~get_flux_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine shellg ( me , glat , glon , alt , dimo , fl , icode , b0 ) class ( shellig_type ), intent ( inout ) :: me real ( wp ), intent ( in ) :: glat !! GEODETIC LATITUDE IN DEGREES (NORTH) real ( wp ), intent ( in ) :: glon !! GEODETIC LONGITUDE IN DEGREES (EAST) real ( wp ), intent ( in ) :: alt !! ALTITUDE IN KM ABOVE SEA LEVEL real ( wp ), intent ( in ) :: dimo !! DIPOL MOMENT IN GAUSS (NORMALIZED TO EARTH RADIUS) real ( wp ), intent ( out ) :: fl !! l-value integer , intent ( out ) :: icode !! * =1 normal completion !! * =2 unphysical conjugate point (fl meaningless) !! * =3 shell parameter greater than limit up to !!   which accurate calculation is required; !!   approximation is used. real ( wp ), intent ( out ) :: b0 !! magnetic field strength in gauss real ( wp ) :: arg1 , arg2 , bequ , bq1 , bq2 , bq3 , c0 , c1 , c2 , c3 , & ct , d , d0 , d1 , d2 , dimob0 , e0 , e1 , e2 , ff , fi , gg , & hli , oradik , oterm , p ( 8 , 100 ) , r , r1 , r2 , r3 , r3h , radik , & rlat , rlon , rq , st , step12 , step2 , & stp , t , term , v ( 3 ) , xx , z , zq , zz integer :: i , iequ , n real ( wp ), parameter :: rmin = 0.05_wp !! boundaries for identification of `icode=2 and 3` real ( wp ), parameter :: rmax = 1.01_wp !! boundaries for identification of `icode=2 and 3` bequ = 1.0e10_wp !*****ENTRY POINT SHELLG TO BE USED WITH GEODETIC CO-ORDINATES rlat = Glat * Umr ct = sin ( rlat ) st = cos ( rlat ) d = sqrt ( Aquad - ( Aquad - Bquad ) * ct * ct ) me % Xi ( 1 ) = ( Alt + Aquad / d ) * st / Era me % Xi ( 3 ) = ( Alt + Bquad / d ) * ct / Era rlon = Glon * Umr me % Xi ( 2 ) = me % Xi ( 1 ) * sin ( rlon ) me % Xi ( 1 ) = me % Xi ( 1 ) * cos ( rlon ) CALL spag_block_1 () RETURN !*****ENTRY POINT SHELLC TO BE USED WITH CARTESIAN CO-ORDINATES   ! JW : does not appear to be used anywhere. !    V(3)  CARTESIAN COORDINATES IN EARTH RADII (6371.2 KM) !      X-AXIS POINTING TO EQUATOR AT 0 LONGITUDE !      Y-AXIS POINTING TO EQUATOR AT 90 LONG. !      Z-AXIS POINTING TO NORTH POLE ENTRY shellc ( me , V , Fl , B0 ) me % Xi ( 1 ) = V ( 1 ) me % Xi ( 2 ) = V ( 2 ) me % Xi ( 3 ) = V ( 3 ) CALL spag_block_1 () CONTAINS subroutine spag_block_1 integer , parameter :: max_loop_index = 100 ! 3333   <--- JW : original code had 3333 ... was this a bug ???? !*****CONVERT TO DIPOL-ORIENTED CO-ORDINATES rq = 1.0_wp / ( me % Xi ( 1 ) * me % Xi ( 1 ) + me % Xi ( 2 ) * me % Xi ( 2 ) + me % Xi ( 3 ) * me % Xi ( 3 )) r3h = sqrt ( rq * sqrt ( rq )) p ( 1 , 2 ) = ( me % Xi ( 1 ) * u ( 1 , 1 ) + me % Xi ( 2 ) * u ( 2 , 1 ) + me % Xi ( 3 ) * u ( 3 , 1 )) * r3h p ( 2 , 2 ) = ( me % Xi ( 1 ) * u ( 1 , 2 ) + me % Xi ( 2 ) * u ( 2 , 2 )) * r3h p ( 3 , 2 ) = ( me % Xi ( 1 ) * u ( 1 , 3 ) + me % Xi ( 2 ) * u ( 2 , 3 ) + me % Xi ( 3 ) * u ( 3 , 3 )) * rq !     *****FIRST THREE POINTS OF FIELD LINE me % step = - sign ( me % step , p ( 3 , 2 )) call me % stoer ( p ( 1 , 2 ), bq2 , r2 ) B0 = sqrt ( bq2 ) p ( 1 , 3 ) = p ( 1 , 2 ) + 0.5_wp * me % step * p ( 4 , 2 ) p ( 2 , 3 ) = p ( 2 , 2 ) + 0.5_wp * me % step * p ( 5 , 2 ) p ( 3 , 3 ) = p ( 3 , 2 ) + 0.5_wp * me % step call me % stoer ( p ( 1 , 3 ), bq3 , r3 ) p ( 1 , 1 ) = p ( 1 , 2 ) - me % step * ( 2.0_wp * p ( 4 , 2 ) - p ( 4 , 3 )) p ( 2 , 1 ) = p ( 2 , 2 ) - me % step * ( 2.0_wp * p ( 5 , 2 ) - p ( 5 , 3 )) p ( 3 , 1 ) = p ( 3 , 2 ) - me % step call me % stoer ( p ( 1 , 1 ), bq1 , r1 ) p ( 1 , 3 ) = p ( 1 , 2 ) + me % step * ( 2 0.0_wp * p ( 4 , 3 ) - 3. * p ( 4 , 2 ) + p ( 4 , 1 )) / 1 8.0_wp p ( 2 , 3 ) = p ( 2 , 2 ) + me % step * ( 2 0.0_wp * p ( 5 , 3 ) - 3. * p ( 5 , 2 ) + p ( 5 , 1 )) / 1 8.0_wp p ( 3 , 3 ) = p ( 3 , 2 ) + me % step call me % stoer ( p ( 1 , 3 ), bq3 , r3 ) !*****INVERT SENSE IF REQUIRED IF ( bq3 > bq1 ) THEN me % step = - me % step r3 = r1 bq3 = bq1 DO i = 1 , 7 zz = p ( i , 1 ) p ( i , 1 ) = p ( i , 3 ) p ( i , 3 ) = zz ENDDO ENDIF !*****SEARCH FOR LOWEST MAGNETIC FIELD STRENGTH IF ( bq1 < bequ ) THEN bequ = bq1 iequ = 1 ENDIF IF ( bq2 < bequ ) THEN bequ = bq2 iequ = 2 ENDIF IF ( bq3 < bequ ) THEN bequ = bq3 iequ = 3 ENDIF !*****INITIALIZATION OF INTEGRATION LOOPS step12 = me % step / 1 2.0_wp step2 = me % step + me % step me % steq = sign ( me % steq , me % step ) fi = 0.0_wp Icode = 1 oradik = 0.0_wp oterm = 0.0_wp stp = r2 * me % steq z = p ( 3 , 2 ) + stp stp = stp / 0.75_wp p ( 8 , 1 ) = step2 * ( p ( 1 , 1 ) * p ( 4 , 1 ) + p ( 2 , 1 ) * p ( 5 , 1 )) p ( 8 , 2 ) = step2 * ( p ( 1 , 2 ) * p ( 4 , 2 ) + p ( 2 , 2 ) * p ( 5 , 2 )) !*****MAIN LOOP (FIELD LINE TRACING) main : DO n = 3 , max_loop_index !*****CORRECTOR (FIELD LINE TRACING) p ( 1 , n ) = p ( 1 , n - 1 ) + step12 * ( 5.0_wp * p ( 4 , n ) + 8.0_wp * p ( 4 , n - 1 ) - p ( 4 , n - 2 )) p ( 2 , n ) = p ( 2 , n - 1 ) + step12 * ( 5.0_wp * p ( 5 , n ) + 8.0_wp * p ( 5 , n - 1 ) - p ( 5 , n - 2 )) !*****PREPARE EXPANSION COEFFICIENTS FOR INTERPOLATION !*****OF SLOWLY VARYING QUANTITIES p ( 8 , n ) = step2 * ( p ( 1 , n ) * p ( 4 , n ) + p ( 2 , n ) * p ( 5 , n )) c0 = p ( 1 , n - 1 ) ** 2 + p ( 2 , n - 1 ) ** 2 c1 = p ( 8 , n - 1 ) c2 = ( p ( 8 , n ) - p ( 8 , n - 2 )) * 0.25_wp c3 = ( p ( 8 , n ) + p ( 8 , n - 2 ) - c1 - c1 ) / 6.0_wp d0 = p ( 6 , n - 1 ) d1 = ( p ( 6 , n ) - p ( 6 , n - 2 )) * 0.5_wp d2 = ( p ( 6 , n ) + p ( 6 , n - 2 ) - d0 - d0 ) * 0.5_wp e0 = p ( 7 , n - 1 ) e1 = ( p ( 7 , n ) - p ( 7 , n - 2 )) * 0.5_wp e2 = ( p ( 7 , n ) + p ( 7 , n - 2 ) - e0 - e0 ) * 0.5_wp inner : DO !*****INNER LOOP (FOR QUADRATURE) t = ( z - p ( 3 , n - 1 )) / me % step IF ( t > 1.0_wp ) THEN !*****PREDICTOR (FIELD LINE TRACING) p ( 1 , n + 1 ) = p ( 1 , n ) + step12 * ( 2 3.0_wp * p ( 4 , n ) - 1 6.0_wp * p ( 4 , n - 1 ) + 5.0_wp * p ( 4 , n - 2 )) p ( 2 , n + 1 ) = p ( 2 , n ) + step12 * ( 2 3.0_wp * p ( 5 , n ) - 1 6.0_wp * p ( 5 , n - 1 ) + 5.0_wp * p ( 5 , n - 2 )) p ( 3 , n + 1 ) = p ( 3 , n ) + me % step call me % stoer ( p ( 1 , n + 1 ), bq3 , r3 ) !*****SEARCH FOR LOWEST MAGNETIC FIELD STRENGTH IF ( bq3 < bequ ) THEN iequ = n + 1 bequ = bq3 ENDIF EXIT inner ELSE hli = 0.5_wp * ((( c3 * t + c2 ) * t + c1 ) * t + c0 ) zq = z * z r = hli + sqrt ( hli * hli + zq ) IF ( r <= rmin ) THEN !*****APPROXIMATION FOR HIGH VALUES OF L. Icode = 3 t = - p ( 3 , n - 1 ) / me % step Fl = 1.0_wp / ( abs ((( c3 * t + c2 ) * t + c1 ) * t + c0 ) + 1.0e-15_wp ) RETURN ENDIF rq = r * r ff = sqrt ( 1.0_wp + 3.0_wp * zq / rq ) radik = B0 - (( d2 * t + d1 ) * t + d0 ) * r * rq * ff IF ( r > rmax ) THEN Icode = 2 radik = radik - 1 2.0_wp * ( r - rmax ) ** 2 ENDIF IF ( radik + radik <= oradik ) EXIT main term = sqrt ( radik ) * ff * (( e2 * t + e1 ) * t + e0 ) / ( rq + zq ) fi = fi + stp * ( oterm + term ) oradik = radik oterm = term stp = r * me % steq z = z + stp ENDIF ENDDO inner ENDDO main IF ( iequ < 2 ) iequ = 2 me % Sp ( 1 ) = p ( 1 , iequ - 1 ) me % Sp ( 2 ) = p ( 2 , iequ - 1 ) me % Sp ( 3 ) = p ( 3 , iequ - 1 ) IF ( oradik >= 1.0e-15_wp ) fi = fi + stp / 0.75_wp * oterm * oradik / ( oradik - radik ) ! !-- The minimal allowable value of FI was changed from 1E-15 to 1E-12, !-- because 1E-38 is the minimal allowable arg. for ALOG in our envir. !-- D. Bilitza, Nov 87. ! fi = 0.5_wp * abs ( fi ) / sqrt ( B0 ) + 1.0e-12_wp !*****COMPUTE L FROM B AND I.  SAME AS CARMEL IN INVAR. ! !-- Correct dipole moment is used here. D. Bilitza, Nov 87. ! dimob0 = Dimo / B0 arg1 = log ( fi ) arg2 = log ( dimob0 ) !       arg = FI*FI*FI/DIMOB0 !       if(abs(arg)>88.0_wp) arg=88.0_wp xx = 3 * arg1 - arg2 IF ( xx > 2 3.0_wp ) THEN gg = xx - 3.0460681_wp ELSEIF ( xx > 1 1.7_wp ) THEN gg = ((((( 2.8212095E-8_wp * xx - 3.8049276E-6_wp ) * xx + & 2.170224E-4_wp ) * xx - 6.7310339E-3_wp ) * xx + & 1.2038224E-1_wp ) * xx - 1.8461796E-1_wp ) * xx + 2.0007187_wp ELSEIF ( xx >+ 3.0_wp ) THEN gg = (((((((( 6.3271665E-10_wp * xx - 3.958306E-8_wp ) * xx + & 9.9766148E-07_wp ) * xx - 1.2531932E-5_wp ) * xx + & 7.9451313E-5_wp ) * xx - 3.2077032E-4_wp ) * xx + & 2.1680398E-3_wp ) * xx + 1.2817956E-2_wp ) * xx + & 4.3510529E-1_wp ) * xx + 6.222355E-1_wp ELSEIF ( xx >- 3.0_wp ) THEN gg = (((((((( 2.6047023E-10_wp * xx + 2.3028767E-9_wp ) * xx - & 2.1997983E-8_wp ) * xx - 5.3977642E-7_wp ) * xx - & 3.3408822E-6_wp ) * xx + 3.8379917E-5_wp ) * xx + & 1.1784234E-3_wp ) * xx + 1.4492441E-2_wp ) * xx + & 4.3352788E-1_wp ) * xx + 6.228644E-1_wp ELSEIF ( xx >- 2 2.0_wp ) THEN gg = (((((((( - 8.1537735E-14_wp * xx + 8.3232531E-13_wp ) * xx + & 1.0066362E-9_wp ) * xx + 8.1048663E-8_wp ) * xx + & 3.2916354E-6_wp ) * xx + 8.2711096E-5_wp ) * xx + & 1.3714667E-3_wp ) * xx + 1.5017245E-2_wp ) * xx + & 4.3432642E-1_wp ) * xx + 6.2337691E-1_wp ELSE gg = 3.33338E-1_wp * xx + 3.0062102E-1_wp ENDIF Fl = exp ( log (( 1.0_wp + exp ( gg )) * dimob0 ) / 3.0_wp ) RETURN END subroutine spag_block_1 END subroutine shellg","tags":"","loc":"proc/shellg.html"},{"title":"stoer – radbelt","text":"private  subroutine stoer(me, p, bq, r) subroutine used for field line tracing in shellg calls entry point feldi in geomagnetic field subroutine feldg Type Bound shellig_type Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me real(kind=wp), intent(inout), dimension(7) :: p real(kind=wp), intent(out) :: bq real(kind=wp), intent(out) :: r Calls proc~~stoer~~CallsGraph proc~stoer shellig_module::shellig_type%stoer feldi feldi proc~stoer->feldi Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~stoer~~CalledByGraph proc~stoer shellig_module::shellig_type%stoer proc~findb0 shellig_module::shellig_type%findb0 proc~findb0->proc~stoer proc~shellg shellig_module::shellig_type%shellg proc~shellg->proc~stoer proc~igrf shellig_module::shellig_type%igrf proc~igrf->proc~findb0 proc~igrf->proc~shellg proc~get_flux_ core::radbelt_type%get_flux_ proc~get_flux_->proc~igrf proc~get_flux core::get_flux proc~get_flux->proc~get_flux_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine stoer ( me , p , bq , r ) class ( shellig_type ), intent ( inout ) :: me real ( wp ), dimension ( 7 ), intent ( inout ) :: p real ( wp ), intent ( out ) :: bq real ( wp ), intent ( out ) :: r real ( wp ) :: dr , dsq , dx , dxm , dy , dym , dz , & dzm , fli , q , rq , wr , xm , ym , zm !*****XM,YM,ZM ARE GEOMAGNETIC CARTESIAN INVERSE CO-ORDINATES zm = P ( 3 ) fli = P ( 1 ) * P ( 1 ) + P ( 2 ) * P ( 2 ) + 1.0e-15_wp R = 0.5_wp * ( fli + sqrt ( fli * fli + ( zm + zm ) ** 2 )) rq = R * R wr = sqrt ( R ) xm = P ( 1 ) * wr ym = P ( 2 ) * wr !*****TRANSFORM TO GEOGRAPHIC CO-ORDINATE SYSTEM me % Xi ( 1 ) = xm * u ( 1 , 1 ) + ym * u ( 1 , 2 ) + zm * u ( 1 , 3 ) me % Xi ( 2 ) = xm * u ( 2 , 1 ) + ym * u ( 2 , 2 ) + zm * u ( 2 , 3 ) me % Xi ( 3 ) = xm * u ( 3 , 1 ) + zm * u ( 3 , 3 ) !*****COMPUTE DERIVATIVES ! Changed from CALL FELDI(XI,H); XI, H are in COMMON block; results ! are the same; dkb Feb 1998. ! JW : feb 2024 : xi, h now class variables. CALL feldi ( me ) q = me % H ( 1 ) / rq dx = me % H ( 3 ) + me % H ( 3 ) + q * me % Xi ( 1 ) dy = me % H ( 4 ) + me % H ( 4 ) + q * me % Xi ( 2 ) dz = me % H ( 2 ) + me % H ( 2 ) + q * me % Xi ( 3 ) !*****TRANSFORM BACK TO GEOMAGNETIC CO-ORDINATE SYSTEM dxm = u ( 1 , 1 ) * dx + u ( 2 , 1 ) * dy + u ( 3 , 1 ) * dz dym = u ( 1 , 2 ) * dx + u ( 2 , 2 ) * dy dzm = u ( 1 , 3 ) * dx + u ( 2 , 3 ) * dy + u ( 3 , 3 ) * dz dr = ( xm * dxm + ym * dym + zm * dzm ) / R !*****FORM SLOWLY VARYING EXPRESSIONS P ( 4 ) = ( wr * dxm - 0.5_wp * P ( 1 ) * dr ) / ( R * dzm ) P ( 5 ) = ( wr * dym - 0.5_wp * P ( 2 ) * dr ) / ( R * dzm ) dsq = rq * ( dxm * dxm + dym * dym + dzm * dzm ) Bq = dsq * rq * rq P ( 6 ) = sqrt ( dsq / ( rq + 3.0_wp * zm * zm )) P ( 7 ) = P ( 6 ) * ( rq + zm * zm ) / ( rq * dzm ) END subroutine stoer","tags":"","loc":"proc/stoer.html"},{"title":"feldg – radbelt","text":"private  subroutine feldg(me, glat, glon, alt, bnorth, beast, bdown, Babs) Calculates earth magnetic field from spherical harmonics model Reference ref: g. kluge, european space operations centre, internal note 61,\n      1970. History changes (d. bilitza, nov 87): field coefficients in binary data files instead of block data calculates dipol moment Type Bound shellig_type Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me real(kind=wp), intent(in) :: glat geodetic latitude in degrees (north) real(kind=wp), intent(in) :: glon geodetic longitude in degrees (east) real(kind=wp), intent(in) :: alt altitude in km above sea level real(kind=wp), intent(out) :: bnorth components of the field with respect\nto the local geodetic coordinate system, with axis\npointing in the tangential plane to the north, east\nand downward. real(kind=wp), intent(out) :: beast components of the field with respect\nto the local geodetic coordinate system, with axis\npointing in the tangential plane to the north, east\nand downward. real(kind=wp), intent(out) :: bdown components of the field with respect\nto the local geodetic coordinate system, with axis\npointing in the tangential plane to the north, east\nand downward. real(kind=wp), intent(out) :: Babs magnetic field strength in gauss Calls proc~~feldg~~CallsGraph proc~feldg shellig_module::shellig_type%feldg feldc feldc proc~feldg->feldc feldi feldi proc~feldg->feldi Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~feldg~~CalledByGraph proc~feldg shellig_module::shellig_type%feldg proc~igrf shellig_module::shellig_type%igrf proc~igrf->proc~feldg proc~get_flux_ core::radbelt_type%get_flux_ proc~get_flux_->proc~igrf proc~get_flux core::get_flux proc~get_flux->proc~get_flux_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine feldg ( me , glat , glon , alt , bnorth , beast , bdown , babs ) class ( shellig_type ), intent ( inout ) :: me real ( wp ), intent ( in ) :: glat !! geodetic latitude in degrees (north) real ( wp ), intent ( in ) :: glon !! geodetic longitude in degrees (east) real ( wp ), intent ( in ) :: alt !! altitude in km above sea level real ( wp ), intent ( out ) :: bnorth , beast , bdown !! components of the field with respect !! to the local geodetic coordinate system, with axis !! pointing in the tangential plane to the north, east !! and downward. real ( wp ), intent ( out ) :: Babs !! magnetic field strength in gauss real ( wp ) :: b ( 3 ) , brho , bxxx , & byyy , bzzz , cp , ct , d , f , rho , & rlat , rlon , rq , s , sp , st , t , v ( 3 ) , x , xxx , & y , yyy , z , zzz integer :: i , ih , ihmax , il , imax , is , k , last , m !-- is records entry point ! !*****entry point  feldg  to be used with geodetic co-ordinates is = 1 rlat = glat * umr ct = sin ( rlat ) st = cos ( rlat ) d = sqrt ( aquad - ( aquad - bquad ) * ct * ct ) rlon = glon * umr cp = cos ( rlon ) sp = sin ( rlon ) zzz = ( alt + bquad / d ) * ct / era rho = ( alt + aquad / d ) * st / era xxx = rho * cp yyy = rho * sp goto 10 !*****entry point  feldc  to be used with cartesian co-ordinates !        v(3)  cartesian coordinates in earth radii (6371.2 km) !            x-axis pointing to equator at 0 longitude !            y-axis pointing to equator at 90 long. !            z-axis pointing to north pole entry feldc ( me , v , b ) is = 2 xxx = v ( 1 ) yyy = v ( 2 ) zzz = v ( 3 ) 10 rq = 1.0_wp / ( xxx * xxx + yyy * yyy + zzz * zzz ) me % xi ( 1 ) = xxx * rq me % xi ( 2 ) = yyy * rq me % xi ( 3 ) = zzz * rq goto 20 !*****entry point  feldi  used for l computation entry feldi ( me ) is = 3 20 ihmax = me % nmax * me % nmax + 1 last = ihmax + me % nmax + me % nmax imax = me % nmax + me % nmax - 1 do i = ihmax , last me % h ( i ) = me % g ( i ) end do do k = 1 , 3 , 2 i = imax ih = ihmax do il = ih - i f = 2.0_wp / real ( i - k + 2 , wp ) x = me % xi ( 1 ) * f y = me % xi ( 2 ) * f z = me % xi ( 3 ) * ( f + f ) i = i - 2 if (( i - 1 ) >= 0 ) then if (( i - 1 ) > 0 ) then do m = 3 , i , 2 me % h ( il + m + 1 ) = me % g ( il + m + 1 ) + z * me % h ( ih + m + 1 ) + x * ( me % h ( ih + m + 3 ) - & me % h ( ih + m - 1 )) - y * ( me % h ( ih + m + 2 ) + me % h ( ih + m - 2 )) me % h ( il + m ) = me % g ( il + m ) + z * me % h ( ih + m ) + x * ( me % h ( ih + m + 2 ) - & me % h ( ih + m - 2 )) + y * ( me % h ( ih + m + 3 ) + me % h ( ih + m - 1 )) end do end if me % h ( il + 2 ) = me % g ( il + 2 ) + z * me % h ( ih + 2 ) + x * me % h ( ih + 4 ) - y * ( me % h ( ih + 3 ) + me % h ( ih )) me % h ( il + 1 ) = me % g ( il + 1 ) + z * me % h ( ih + 1 ) + y * me % h ( ih + 4 ) + x * ( me % h ( ih + 3 ) - me % h ( ih )) end if me % h ( il ) = me % g ( il ) + z * me % h ( ih ) + 2.0_wp * ( x * me % h ( ih + 1 ) + y * me % h ( ih + 2 )) ih = il if ( i < k ) exit end do end do if ( is == 3 ) return s = 0.5_wp * me % h ( 1 ) + 2.0_wp * ( me % h ( 2 ) * me % xi ( 3 ) + me % h ( 3 ) * me % xi ( 1 ) + me % h ( 4 ) * me % xi ( 2 )) t = ( rq + rq ) * sqrt ( rq ) bxxx = t * ( me % h ( 3 ) - s * xxx ) byyy = t * ( me % h ( 4 ) - s * yyy ) bzzz = t * ( me % h ( 2 ) - s * zzz ) if ( is == 2 ) then b ( 1 ) = bxxx b ( 2 ) = byyy b ( 3 ) = bzzz else babs = sqrt ( bxxx * bxxx + byyy * byyy + bzzz * bzzz ) beast = byyy * cp - bxxx * sp brho = byyy * sp + bxxx * cp bnorth = bzzz * st - brho * ct bdown =- bzzz * ct - brho * st end if end subroutine feldg","tags":"","loc":"proc/feldg.html"},{"title":"feldcof – radbelt","text":"private  subroutine feldcof(me, year, dimo) Determines coefficients and dipol moment from IGRF models Author D. BILITZA, NSSDC, GSFC, CODE 633, GREENBELT, MD 20771,\n    (301) 286-9536 NOV 1987. History corrected for 2000 update - dkb- 5/31/2000 updated to IGRF-2000 version -dkb- 5/31/2000 updated to IGRF-2005 version -dkb- 3/24/2000 Type Bound shellig_type Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me real(kind=wp), intent(in) :: year decimal year for which geomagnetic field is to\nbe calculated (e.g.:1995.5 for day 185 of 1995) real(kind=wp), intent(out) :: dimo geomagnetic dipol moment in gauss (normalized\nto earth's radius) at the time (year) Calls proc~~feldcof~~CallsGraph proc~feldcof shellig_module::shellig_type%feldcof proc~extrashc shellig_module::shellig_type%extrashc proc~feldcof->proc~extrashc proc~get_data_file_dir shellig_module::shellig_type%get_data_file_dir proc~feldcof->proc~get_data_file_dir proc~getshc shellig_module::shellig_type%getshc proc~feldcof->proc~getshc proc~intershc shellig_module::shellig_type%intershc proc~feldcof->proc~intershc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~feldcof~~CalledByGraph proc~feldcof shellig_module::shellig_type%feldcof proc~igrf shellig_module::shellig_type%igrf proc~igrf->proc~feldcof proc~get_flux_ core::radbelt_type%get_flux_ proc~get_flux_->proc~igrf proc~get_flux core::get_flux proc~get_flux->proc~get_flux_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine feldcof ( me , year , dimo ) class ( shellig_type ), intent ( inout ) :: me real ( wp ), intent ( in ) :: year !! decimal year for which geomagnetic field is to !! be calculated (e.g.:1995.5 for day 185 of 1995) real ( wp ), intent ( out ) :: dimo !! geomagnetic dipol moment in gauss (normalized !! to earth's radius) at the time (year) real ( wp ) :: dte1 , dte2 , erad , gha ( 144 ) , sqrt2 integer :: i , ier , j , l , m , n , iyea character ( len = :), allocatable :: fil2 real ( wp ) :: x , f0 , f !! these were double precision in original !! code while everything else was single precision ! changed to conform with IGRF 45-95, also FILMOD, DTEMOD arrays +1 character ( len = filename_len ), dimension ( 17 ), parameter :: filmod = [& 'dgrf1945.dat ' , 'dgrf1950.dat ' , 'dgrf1955.dat ' , 'dgrf1960.dat ' , & 'dgrf1965.dat ' , 'dgrf1970.dat ' , 'dgrf1975.dat ' , 'dgrf1980.dat ' , & 'dgrf1985.dat ' , 'dgrf1990.dat ' , 'dgrf1995.dat ' , 'dgrf2000.dat ' , & 'dgrf2005.dat ' , 'dgrf2010.dat ' , 'dgrf2015.dat ' , 'igrf2020.dat ' , & 'igrf2020s.dat' ] real ( wp ), dimension ( 17 ), parameter :: dtemod = [ 194 5.0_wp , 195 0.0_wp , 195 5.0_wp , & 196 0.0_wp , 196 5.0_wp , 197 0.0_wp , & 197 5.0_wp , 198 0.0_wp , 198 5.0_wp , & 199 0.0_wp , 199 5.0_wp , 200 0.0_wp , & 200 5.0_wp , 201 0.0_wp , 201 5.0_wp , & 202 0.0_wp , 202 5.0_wp ] integer , parameter :: numye = size ( dtemod ) - 1 ! number of 5-year priods represented by IGRF integer , parameter :: is = 0 !! * is=0 for schmidt normalization !! * is=1 gauss normalization logical :: read_file !-- determine igrf-years for input-year me % time = year iyea = int ( year / 5.0_wp ) * 5 read_file = iyea /= me % iyea ! if we have to read the file me % iyea = iyea l = ( me % iyea - 1945 ) / 5 + 1 if ( l < 1 ) l = 1 if ( l > numye ) l = numye dte1 = dtemod ( l ) me % name = me % get_data_file_dir () // trim ( filmod ( l )) dte2 = dtemod ( l + 1 ) fil2 = me % get_data_file_dir () // trim ( filmod ( l + 1 )) if ( read_file ) then ! get igrf coefficients for the boundary years ! [if they have not ready been loaded] call me % getshc ( me % name , me % nmax1 , erad , me % g , ier ) if ( ier /= 0 ) error stop 'error reading file: ' // trim ( me % name ) me % g_cache = me % g ! because it is modified below, we have to cache the original values from the file call me % getshc ( fil2 , me % nmax2 , erad , me % gh2 , ier ) if ( ier /= 0 ) error stop 'error reading file: ' // trim ( fil2 ) else me % g = me % g_cache end if !-- determine igrf coefficients for year if ( l <= numye - 1 ) then call me % intershc ( year , dte1 , me % nmax1 , me % g , dte2 , me % nmax2 , me % gh2 , me % nmax , gha ) else call me % extrashc ( year , dte1 , me % nmax1 , me % g , me % nmax2 , me % gh2 , me % nmax , gha ) endif !-- determine magnetic dipol moment and coeffiecients g f0 = 0.0_wp do j = 1 , 3 f = gha ( j ) * 1.0e-5_wp f0 = f0 + f * f enddo dimo = sqrt ( f0 ) me % g ( 1 ) = 0.0_wp i = 2 f0 = 1.0e-5_wp if ( is == 0 ) f0 = - f0 sqrt2 = sqrt ( 2.0_wp ) do n = 1 , me % nmax x = n f0 = f0 * x * x / ( 4.0_wp * x - 2.0_wp ) if ( is == 0 ) f0 = f0 * ( 2.0_wp * x - 1.0_wp ) / x f = f0 * 0.5_wp if ( is == 0 ) f = f * sqrt2 me % g ( i ) = gha ( i - 1 ) * f0 i = i + 1 do m = 1 , n f = f * ( x + m ) / ( x - m + 1.0_wp ) if ( is == 0 ) f = f * sqrt (( x - m + 1.0_wp ) / ( x + m )) me % g ( i ) = gha ( i - 1 ) * f me % g ( i + 1 ) = gha ( i ) * f i = i + 2 enddo enddo end subroutine feldcof","tags":"","loc":"proc/feldcof.html"},{"title":"getshc – radbelt","text":"private  subroutine getshc(me, Fspec, Nmax, Erad, Gh, Ier) Reads spherical harmonic coefficients from the specified\n  file into an array. Author Version 1.01, A. Zunde, USGS, MS 964,\n    Box 25046 Federal Center, Denver, CO  80225 Type Bound shellig_type Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me character(len=*), intent(in) :: Fspec File specification integer, intent(out) :: Nmax Maximum degree and order of model real(kind=wp), intent(out) :: Erad Earth's radius associated with the spherical\nharmonic coefficients, in the same units as\nelevation real(kind=wp), intent(out), dimension(*) :: Gh Schmidt quasi-normal internal spherical\nharmonic coefficients integer, intent(out) :: Ier Error number: 0, no error -2, records out of order FORTRAN run-time error number Called by proc~~getshc~~CalledByGraph proc~getshc shellig_module::shellig_type%getshc proc~feldcof shellig_module::shellig_type%feldcof proc~feldcof->proc~getshc proc~igrf shellig_module::shellig_type%igrf proc~igrf->proc~feldcof proc~get_flux_ core::radbelt_type%get_flux_ proc~get_flux_->proc~igrf proc~get_flux core::get_flux proc~get_flux->proc~get_flux_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine getshc ( me , Fspec , Nmax , Erad , Gh , Ier ) class ( shellig_type ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: Fspec !! File specification integer , intent ( out ) :: Nmax !! Maximum degree and order of model real ( wp ), intent ( out ) :: Erad !! Earth's radius associated with the spherical !! harmonic coefficients, in the same units as !! elevation real ( wp ), dimension ( * ), intent ( out ) :: Gh !! Schmidt quasi-normal internal spherical !! harmonic coefficients integer , intent ( out ) :: Ier !! Error number: !! !!  * 0, no error !!  * -2, records out of order !!  * FORTRAN run-time error number integer :: iu !! logical unit number real ( wp ) :: g , h integer :: i , m , mm , n , nn read_file : block ! --------------------------------------------------------------- !  Open coefficient file. Read past first header record. !  Read degree and order of model and Earth's radius. ! --------------------------------------------------------------- OPEN ( newunit = Iu , FILE = Fspec , STATUS = 'OLD' , IOSTAT = Ier ) if ( Ier /= 0 ) then write ( * , * ) 'Error opening file: ' // trim ( fspec ) exit read_file end if READ ( Iu , * , IOSTAT = Ier ) if ( Ier /= 0 ) exit read_file READ ( Iu , * , IOSTAT = Ier ) Nmax , Erad if ( Ier /= 0 ) exit read_file ! --------------------------------------------------------------- !  Read the coefficient file, arranged as follows: ! !          N     M     G     H !          ---------------------- !            /   1     0    GH(1)  - !           /  1     1    GH(2) GH(3) !          /  2     0    GH(4)  - !         /  2     1    GH(5) GH(6) !      NMAX*(NMAX+3)/2   /  2     2    GH(7) GH(8) !         records    \\  3     0    GH(9)  - !         \\      .     .     .     . !          \\  .     .     .     . !      NMAX*(NMAX+2)     \\  .     .     .     . !      elements in GH      \\  NMAX  NMAX   .     . ! !  N and M are, respectively, the degree and order of the !  coefficient. ! --------------------------------------------------------------- i = 0 main : DO nn = 1 , Nmax DO mm = 0 , nn READ ( Iu , * , IOSTAT = Ier ) n , m , g , h if ( Ier /= 0 ) exit main IF ( nn /= n . OR . mm /= m ) THEN Ier = - 2 EXIT main ENDIF i = i + 1 Gh ( i ) = g IF ( m /= 0 ) THEN i = i + 1 Gh ( i ) = h ENDIF ENDDO ENDDO main end block read_file CLOSE ( Iu ) END subroutine getshc","tags":"","loc":"proc/getshc.html"},{"title":"intershc – radbelt","text":"private  subroutine intershc(me, date, dte1, nmax1, gh1, dte2, nmax2, gh2, nmax, gh) Interpolates linearly, in time, between two spherical\n  harmonic models. The coefficients (GH) of the resulting model, at date\n  DATE, are computed by linearly interpolating between the\n  coefficients of the earlier model (GH1), at date DTE1,\n  and those of the later model (GH2), at date DTE2. If one\n  model is smaller than the other, the interpolation is\n  performed with the missing coefficients assumed to be 0. Author Version 1.01, A. Zunde\n    USGS, MS 964, Box 25046 Federal Center, Denver, CO  80225 Type Bound shellig_type Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me real(kind=wp), intent(in) :: date Date of resulting model (in decimal year) real(kind=wp), intent(in) :: dte1 Date of earlier model integer, intent(in) :: nmax1 Maximum degree and order of earlier model real(kind=wp), intent(in) :: gh1 (*) Schmidt quasi-normal internal spherical harmonic coefficients of earlier model real(kind=wp), intent(in) :: dte2 Date of later model integer, intent(in) :: nmax2 Maximum degree and order of later model real(kind=wp), intent(in) :: gh2 (*) Schmidt quasi-normal internal spherical harmonic coefficients of later model integer, intent(out) :: nmax Maximum degree and order of resulting model real(kind=wp), intent(out) :: gh (*) Coefficients of resulting model Called by proc~~intershc~~CalledByGraph proc~intershc shellig_module::shellig_type%intershc proc~feldcof shellig_module::shellig_type%feldcof proc~feldcof->proc~intershc proc~igrf shellig_module::shellig_type%igrf proc~igrf->proc~feldcof proc~get_flux_ core::radbelt_type%get_flux_ proc~get_flux_->proc~igrf proc~get_flux core::get_flux proc~get_flux->proc~get_flux_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine intershc ( me , date , dte1 , nmax1 , gh1 , dte2 , nmax2 , gh2 , nmax , gh ) class ( shellig_type ), intent ( inout ) :: me real ( wp ), intent ( in ) :: date !! Date of resulting model (in decimal year) real ( wp ), intent ( in ) :: dte1 !! Date of earlier model integer , intent ( in ) :: nmax1 !! Maximum degree and order of earlier model real ( wp ), intent ( in ) :: gh1 ( * ) !! Schmidt quasi-normal internal spherical harmonic coefficients of earlier model real ( wp ), intent ( in ) :: dte2 !! Date of later model integer , intent ( in ) :: nmax2 !! Maximum degree and order of later model real ( wp ), intent ( in ) :: gh2 ( * ) !! Schmidt quasi-normal internal spherical harmonic coefficients of later model real ( wp ), intent ( out ) :: gh ( * ) !! Coefficients of resulting model integer , intent ( out ) :: nmax !! Maximum degree and order of resulting model real ( wp ) :: factor integer :: i , k , l factor = ( date - dte1 ) / ( dte2 - dte1 ) if ( nmax1 == nmax2 ) then k = nmax1 * ( nmax1 + 2 ) nmax = nmax1 elseif ( nmax1 > nmax2 ) then k = nmax2 * ( nmax2 + 2 ) l = nmax1 * ( nmax1 + 2 ) do i = k + 1 , l gh ( i ) = gh1 ( i ) + factor * ( - gh1 ( i )) enddo nmax = nmax1 else k = nmax1 * ( nmax1 + 2 ) l = nmax2 * ( nmax2 + 2 ) do i = k + 1 , l gh ( i ) = factor * gh2 ( i ) enddo nmax = nmax2 endif do i = 1 , k gh ( i ) = gh1 ( i ) + factor * ( gh2 ( i ) - gh1 ( i )) enddo end subroutine intershc","tags":"","loc":"proc/intershc.html"},{"title":"extrashc – radbelt","text":"private  subroutine extrashc(me, date, dte1, nmax1, gh1, nmax2, gh2, nmax, gh) Extrapolates linearly a spherical harmonic model with a\n  rate-of-change model. The coefficients (GH) of the resulting model, at date\n  DATE, are computed by linearly extrapolating the coef-\n  ficients of the base model (GH1), at date DTE1, using\n  those of the rate-of-change model (GH2), at date DTE2. If\n  one model is smaller than the other, the extrapolation is\n  performed with the missing coefficients assumed to be 0. Author Version 1.01, A. Zunde\n    USGS, MS 964, Box 25046 Federal Center, Denver, CO  80225 Type Bound shellig_type Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me real(kind=wp), intent(in) :: date Date of resulting model (in decimal year) real(kind=wp), intent(in) :: dte1 Date of base model integer, intent(in) :: nmax1 Maximum degree and order of base model real(kind=wp), intent(in) :: gh1 (*) Schmidt quasi-normal internal spherical harmonic coefficients of base model integer, intent(in) :: nmax2 Maximum degree and order of rate-of-change model real(kind=wp), intent(in) :: gh2 (*) Schmidt quasi-normal internal spherical harmonic coefficients of rate-of-change model integer, intent(out) :: nmax Maximum degree and order of resulting model real(kind=wp), intent(out) :: gh (*) Coefficients of resulting model Called by proc~~extrashc~~CalledByGraph proc~extrashc shellig_module::shellig_type%extrashc proc~feldcof shellig_module::shellig_type%feldcof proc~feldcof->proc~extrashc proc~igrf shellig_module::shellig_type%igrf proc~igrf->proc~feldcof proc~get_flux_ core::radbelt_type%get_flux_ proc~get_flux_->proc~igrf proc~get_flux core::get_flux proc~get_flux->proc~get_flux_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine extrashc ( me , date , dte1 , nmax1 , gh1 , nmax2 , gh2 , nmax , gh ) class ( shellig_type ), intent ( inout ) :: me real ( wp ), intent ( in ) :: date !! Date of resulting model (in decimal year) real ( wp ), intent ( in ) :: dte1 !! Date of base model integer , intent ( in ) :: nmax1 !! Maximum degree and order of base model real ( wp ), intent ( in ) :: gh1 ( * ) !! Schmidt quasi-normal internal spherical harmonic coefficients of base model integer , intent ( in ) :: nmax2 !! Maximum degree and order of rate-of-change model real ( wp ), intent ( in ) :: gh2 ( * ) !! Schmidt quasi-normal internal spherical harmonic coefficients of rate-of-change model real ( wp ), intent ( out ) :: gh ( * ) !! Coefficients of resulting model integer , intent ( out ) :: nmax !! Maximum degree and order of resulting model real ( wp ) :: factor integer :: i , k , l factor = ( date - dte1 ) if ( nmax1 == nmax2 ) then k = nmax1 * ( nmax1 + 2 ) nmax = nmax1 elseif ( nmax1 > nmax2 ) then k = nmax2 * ( nmax2 + 2 ) l = nmax1 * ( nmax1 + 2 ) do i = k + 1 , l gh ( i ) = gh1 ( i ) enddo nmax = nmax1 else k = nmax1 * ( nmax1 + 2 ) l = nmax2 * ( nmax2 + 2 ) do i = k + 1 , l gh ( i ) = factor * gh2 ( i ) enddo nmax = nmax2 endif do i = 1 , k gh ( i ) = gh1 ( i ) + factor * gh2 ( i ) enddo end subroutine extrashc","tags":"","loc":"proc/extrashc.html"},{"title":"get_data_file_dir – radbelt","text":"private  function get_data_file_dir(me) result(dir) Get the directory containing the data files. Type Bound trm_type Arguments Type Intent Optional Attributes Name class( trm_type ), intent(in) :: me Return Value character(len=:), allocatable Called by proc~~get_data_file_dir~2~~CalledByGraph proc~get_data_file_dir~2 trmfun_module::trm_type%get_data_file_dir proc~aep8 trmfun_module::trm_type%aep8 proc~aep8->proc~get_data_file_dir~2 proc~get_flux_ core::radbelt_type%get_flux_ proc~get_flux_->proc~aep8 proc~get_flux core::get_flux proc~get_flux->proc~get_flux_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function get_data_file_dir ( me ) result ( dir ) class ( trm_type ), intent ( in ) :: me character ( len = :), allocatable :: dir if ( allocated ( me % aep8_dir )) then dir = trim ( me % aep8_dir ) // '/' else dir = 'data/aep8/' ! default end if end function get_data_file_dir","tags":"","loc":"proc/get_data_file_dir~2.html"},{"title":"trara2 – radbelt","text":"private  function trara2(me, map, il, ib) trara2 interpolates linearly in l-b/b0-map to obtain\n  the logarithm of integral flux at given l and b/b0. Note see main program 'model' for explanation of map format\n  scaling factors. Type Bound trm_type Arguments Type Intent Optional Attributes Name class( trm_type ), intent(inout) :: me integer, intent(in) :: map (*) is sub-map (for specific energy) of\ntrapped radiation model map integer, intent(in) :: il scaled l-value integer, intent(in) :: ib scaled b/b0-1 Return Value real(kind=wp) scaled logarithm of particle flux Called by proc~~trara2~~CalledByGraph proc~trara2 trmfun_module::trm_type%trara2 proc~trara1 trmfun_module::trm_type%trara1 proc~trara1->proc~trara2 proc~aep8 trmfun_module::trm_type%aep8 proc~aep8->proc~trara1 proc~get_flux_ core::radbelt_type%get_flux_ proc~get_flux_->proc~aep8 proc~get_flux core::get_flux proc~get_flux->proc~get_flux_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function trara2 ( me , map , il , ib ) class ( trm_type ), intent ( inout ) :: me integer , intent ( in ) :: map ( * ) !! is sub-map (for specific energy) of !! trapped radiation model map integer , intent ( in ) :: il !! scaled l-value integer , intent ( in ) :: ib !! scaled b/b0-1 real ( wp ) :: trara2 !! scaled logarithm of particle flux real ( wp ) :: dfl , fincr1 , fincr2 , fistep , fkb , fkb1 , fkb2 , fkbj1 , fkbj2 , & fkbm , fll1 , fll2 , flog , flog1 , flog2 , flogm , & fnb , fnl , sl1 , sl2 integer :: i1 , i2 , itime , j1 , j2 , kt , l1 , l2 integer :: spag_nextblock_1 fistep = me % fistep spag_nextblock_1 = 1 main : do select case ( spag_nextblock_1 ) case ( 1 ) fnl = il fnb = ib itime = 0 i2 = 0 do ! find consecutive sub-sub-maps for scaled l-values ls1,ls2, ! with il less or equal ls2.  l1,l2 are lengths of sub-sub-maps. ! i1,i2 are indeces of first elements minus 1. l2 = map ( i2 + 1 ) if ( map ( i2 + 2 ) <= il ) then i1 = i2 l1 = l2 i2 = i2 + l2 ! if sub-sub-maps are empty, i. e. length less 4, than trara2=0 elseif ( ( l1 < 4 ) . and . ( l2 < 4 ) ) then trara2 = 0.0_wp return else ! if flog2 less flog1, than ls2 first map and ls1 second map if ( map ( i2 + 3 ) <= map ( i1 + 3 ) ) exit spag_nextblock_1 = 3 cycle main endif enddo spag_nextblock_1 = 2 case ( 2 ) kt = i1 i1 = i2 i2 = kt kt = l1 l1 = l2 l2 = kt spag_nextblock_1 = 3 case ( 3 ) ! determine interpolate in scaled l-value fll1 = map ( i1 + 2 ) fll2 = map ( i2 + 2 ) dfl = ( fnl - fll1 ) / ( fll2 - fll1 ) flog1 = map ( i1 + 3 ) flog2 = map ( i2 + 3 ) fkb1 = 0.0_wp fkb2 = 0.0_wp if ( l1 >= 4 ) then ! b/b0 loop do j2 = 4 , l2 fincr2 = map ( i2 + j2 ) if ( fkb2 + fincr2 > fnb ) goto 10 fkb2 = fkb2 + fincr2 flog2 = flog2 - fistep enddo itime = itime + 1 if ( itime == 1 ) then spag_nextblock_1 = 2 cycle main endif trara2 = 0.0_wp return 10 if ( itime /= 1 ) then if ( j2 == 4 ) then spag_nextblock_1 = 4 cycle main endif sl2 = flog2 / fkb2 do j1 = 4 , l1 fincr1 = map ( i1 + j1 ) fkb1 = fkb1 + fincr1 flog1 = flog1 - fistep fkbj1 = (( flog1 / fistep ) * fincr1 + fkb1 ) / (( fincr1 / fistep ) * sl2 + 1.0_wp ) if ( fkbj1 <= fkb1 ) goto 15 enddo if ( fkbj1 <= fkb2 ) then trara2 = 0.0_wp return endif 15 if ( fkbj1 <= fkb2 ) then fkbm = fkbj1 + ( fkb2 - fkbj1 ) * dfl flogm = fkbm * sl2 flog2 = flog2 - fistep fkb2 = fkb2 + fincr2 sl1 = flog1 / fkb1 sl2 = flog2 / fkb2 spag_nextblock_1 = 5 cycle main else fkb1 = 0.0_wp endif endif fkb2 = 0.0_wp endif j2 = 4 fincr2 = map ( i2 + j2 ) flog2 = map ( i2 + 3 ) flog1 = map ( i1 + 3 ) spag_nextblock_1 = 4 case ( 4 ) flogm = flog1 + ( flog2 - flog1 ) * dfl fkbm = 0.0_wp fkb2 = fkb2 + fincr2 flog2 = flog2 - fistep sl2 = flog2 / fkb2 if ( l1 < 4 ) then fincr1 = 0.0_wp sl1 = - 90000 0.0_wp spag_nextblock_1 = 6 cycle main else j1 = 4 fincr1 = map ( i1 + j1 ) fkb1 = fkb1 + fincr1 flog1 = flog1 - fistep sl1 = flog1 / fkb1 endif spag_nextblock_1 = 5 case ( 5 ) do while ( sl1 >= sl2 ) fkbj2 = (( flog2 / fistep ) * fincr2 + fkb2 ) / (( fincr2 / fistep ) * sl1 + 1.0_wp ) fkb = fkb1 + ( fkbj2 - fkb1 ) * dfl flog = fkb * sl1 if ( fkb >= fnb ) then spag_nextblock_1 = 7 cycle main endif fkbm = fkb flogm = flog if ( j1 >= l1 ) then trara2 = 0.0_wp return else j1 = j1 + 1 fincr1 = map ( i1 + j1 ) flog1 = flog1 - fistep fkb1 = fkb1 + fincr1 sl1 = flog1 / fkb1 endif enddo spag_nextblock_1 = 6 case ( 6 ) fkbj1 = (( flog1 / fistep ) * fincr1 + fkb1 ) / (( fincr1 / fistep ) * sl2 + 1.0_wp ) fkb = fkbj1 + ( fkb2 - fkbj1 ) * dfl flog = fkb * sl2 if ( fkb < fnb ) then fkbm = fkb flogm = flog if ( j2 >= l2 ) then trara2 = 0.0_wp return else j2 = j2 + 1 fincr2 = map ( i2 + j2 ) flog2 = flog2 - fistep fkb2 = fkb2 + fincr2 sl2 = flog2 / fkb2 spag_nextblock_1 = 5 cycle main endif endif spag_nextblock_1 = 7 case ( 7 ) if ( fkb < fkbm + 1.0e-10_wp ) then trara2 = 0.0_wp else trara2 = flogm + ( flog - flogm ) * (( fnb - fkbm ) / ( fkb - fkbm )) trara2 = max ( trara2 , 0.0_wp ) return endif exit main end select enddo main end function trara2","tags":"","loc":"proc/trara2.html"},{"title":"set_data_file_dir – radbelt","text":"private  subroutine set_data_file_dir(me, dir) Set the directory containing the data files. Type Bound trm_type Arguments Type Intent Optional Attributes Name class( trm_type ), intent(inout) :: me character(len=*), intent(in) :: dir Called by proc~~set_data_file_dir~2~~CalledByGraph proc~set_data_file_dir~2 trmfun_module::trm_type%set_data_file_dir proc~set_data_files_paths core::radbelt_type%set_data_files_paths proc~set_data_files_paths->proc~set_data_file_dir~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_data_file_dir ( me , dir ) class ( trm_type ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: dir me % aep8_dir = trim ( dir ) end subroutine set_data_file_dir","tags":"","loc":"proc/set_data_file_dir~2.html"},{"title":"aep8 – radbelt","text":"private  subroutine aep8(me, e, l, bb0, imname, flux) Main wrapper for the radiation model.\nReads the coefficient file and calls the low-level routine. Type Bound trm_type Arguments Type Intent Optional Attributes Name class( trm_type ), intent(inout) :: me real(kind=wp), intent(in) :: e real(kind=wp), intent(in) :: l real(kind=wp), intent(in) :: bb0 integer, intent(in) :: imname which model to load (index in mname array) real(kind=wp), intent(out) :: flux Calls proc~~aep8~~CallsGraph proc~aep8 trmfun_module::trm_type%aep8 proc~get_data_file_dir~2 trmfun_module::trm_type%get_data_file_dir proc~aep8->proc~get_data_file_dir~2 proc~trara1 trmfun_module::trm_type%trara1 proc~aep8->proc~trara1 proc~trara2 trmfun_module::trm_type%trara2 proc~trara1->proc~trara2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~aep8~~CalledByGraph proc~aep8 trmfun_module::trm_type%aep8 proc~get_flux_ core::radbelt_type%get_flux_ proc~get_flux_->proc~aep8 proc~get_flux core::get_flux proc~get_flux->proc~get_flux_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine aep8 ( me , e , l , bb0 , imname , flux ) class ( trm_type ), intent ( inout ) :: me real ( wp ), intent ( in ) :: e real ( wp ), intent ( in ) :: l real ( wp ), intent ( in ) :: bb0 integer , intent ( in ) :: imname !! which model to load (index in `mname` array) real ( wp ), intent ( out ) :: flux real ( wp ) :: ee ( 1 ), f ( 1 ) !! temp variables integer :: i , ierr , iuaeap , nmap character ( len = :), allocatable :: name logical :: load_file name = me % get_data_file_dir () // trim ( mname ( Imname )) ! the file to load ! JW : do we need to reset some or all of these ? me % fistep = 0.0_wp me % f1 = 1.001_wp me % f2 = 1.002_wp ! check to see if this file has already been loaded ! [the class can store one file at a time] load_file = . true . if ( allocated ( me % file_loaded )) then if ( name == me % file_loaded ) load_file = . false . end if if ( load_file ) then open ( newunit = iuaeap , file = name , status = 'OLD' , iostat = ierr , form = 'FORMATTED' ) if ( ierr /= 0 ) then error stop 'error reading ' // trim ( name ) end if read ( iuaeap , '(1X,12I6)' ) me % ihead nmap = me % ihead ( 8 ) allocate ( me % map ( nmap )) read ( iuaeap , '(1X,12I6)' ) ( me % map ( i ), i = 1 , nmap ) close ( iuaeap ) me % file_loaded = trim ( name ) end if ee ( 1 ) = e call me % trara1 ( me % ihead , me % map , L , Bb0 , ee , f , 1 ) flux = f ( 1 ) IF ( Flux > 0.0_wp ) Flux = 1 0.0_wp ** Flux end subroutine aep8","tags":"","loc":"proc/aep8.html"},{"title":"trara1 – radbelt","text":"private  subroutine trara1(me, descr, map, fl, bb0, e, f, n) trara1 finds particle fluxes for given energies, magnetic field\nstrength and l-value. function trara2 is used to interpolate in\nb-l-space. Type Bound trm_type Arguments Type Intent Optional Attributes Name class( trm_type ), intent(inout) :: me integer, intent(in) :: descr (8) header of specified trapped radition model integer, intent(in) :: map (*) map of trapped radition model\n(descr and map are explained at the begin\nof the main program model) real(kind=wp), intent(in) :: fl l-value real(kind=wp), intent(in) :: bb0 =b/b0  magnetic field strength normalized\nto field strength at magnetic equator real(kind=wp), intent(in) :: e (n) array of energies in mev real(kind=wp), intent(out) :: f (n) decadic logarithm of integral fluxes in\nparticles/(cm cm sec) integer, intent(in) :: n number of energies Calls proc~~trara1~~CallsGraph proc~trara1 trmfun_module::trm_type%trara1 proc~trara2 trmfun_module::trm_type%trara2 proc~trara1->proc~trara2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~trara1~~CalledByGraph proc~trara1 trmfun_module::trm_type%trara1 proc~aep8 trmfun_module::trm_type%aep8 proc~aep8->proc~trara1 proc~get_flux_ core::radbelt_type%get_flux_ proc~get_flux_->proc~aep8 proc~get_flux core::get_flux proc~get_flux->proc~get_flux_ Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine trara1 ( me , descr , map , fl , bb0 , e , f , n ) class ( trm_type ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of energies integer , intent ( in ) :: descr ( 8 ) !! header of specified trapped radition model real ( wp ), intent ( in ) :: e ( n ) !! array of energies in mev real ( wp ), intent ( in ) :: fl !! l-value real ( wp ), intent ( in ) :: bb0 !! =b/b0  magnetic field strength normalized !! to field strength at magnetic equator integer , intent ( in ) :: map ( * ) !! map of trapped radition model !! (descr and map are explained at the begin !! of the main program model) real ( wp ), intent ( out ) :: f ( n ) !! decadic logarithm of integral fluxes in !! particles/(cm*cm*sec) real ( wp ) :: e0 , e1 , e2 , escale , f0 , fscale , xnl real ( wp ) :: bb0_ !! local copy of `bb0`. in the original code !! this was modified by this routine. !! added this so `bb0` could be `intent(in)` integer :: i0 , i1 , i2 , i3 , ie , l3 , nb , nl logical :: s0 , s1 , s2 bb0_ = bb0 me % fistep = descr ( 7 ) / descr ( 2 ) escale = descr ( 4 ) fscale = descr ( 7 ) xnl = min ( 1 5.6_wp , abs ( fl )) nl = xnl * descr ( 5 ) if ( bb0_ < 1.0_wp ) bb0_ = 1.0_wp nb = ( bb0_ - 1.0_wp ) * descr ( 6 ) ! i2 is the number of elements in the flux map for the first energy. ! i3 is the index of the last element of the second energy map. ! l3 is the length of the map for the third energy. ! e1 is the energy of the first energy map (unscaled) ! e2 is the energy of the second energy map (unscaled) i1 = 0 i2 = map ( 1 ) i3 = i2 + map ( i2 + 1 ) l3 = map ( i3 + 1 ) e1 = map ( i1 + 2 ) / escale e2 = map ( i2 + 2 ) / escale ! s0, s1, s2 are logical variables which indicate whether the flux for ! a particular e, b, l point has already been found in a previous call ! to function trara2. if not, s.. =.true. s1 = . true . s2 = . true . ! energy loop do ie = 1 , n ! for each energy e(i) find the successive energies e0,e1,e2 in ! model map, which obey  e0 < e1 < e(i) < e2 . do while ( ( e ( ie ) > e2 ) . and . ( l3 /= 0 ) ) i0 = i1 i1 = i2 i2 = i3 i3 = i3 + l3 l3 = map ( i3 + 1 ) e0 = e1 e1 = e2 e2 = map ( i2 + 2 ) / escale s0 = s1 s1 = s2 s2 = . true . f0 = me % f1 me % f1 = me % f2 enddo ! call trara2 to interpolate the flux-maps for e1,e2 in l-b/b0- ! space to find fluxes f1,f2 [if they have not already been ! calculated for a previous e(i)]. if ( s1 ) me % f1 = me % trara2 ( map ( i1 + 3 ), nl , nb ) / fscale if ( s2 ) me % f2 = me % trara2 ( map ( i2 + 3 ), nl , nb ) / fscale s1 = . false . s2 = . false . ! finally, interpolate in energy. f ( ie ) = me % f1 + ( me % f2 - me % f1 ) * ( e ( ie ) - e1 ) / ( e2 - e1 ) if ( me % f2 <= 0.0_wp ) then if ( i1 /= 0 ) then ! --------- special interpolation --------------------------------- ! if the flux for the second energy cannot be found (i.e. f2=0.0), ! and the zeroth energy map has been defined (i.e. i1 not equal 0), ! then interpolate using the flux maps for the zeroth and first ! energy and choose the minimum of this interpolations and the ! interpolation that was done with f2=0. if ( s0 ) f0 = me % trara2 ( map ( i0 + 3 ), nl , nb ) / fscale s0 = . false . f ( ie ) = min ( f ( ie ), f0 + ( me % f1 - f0 ) * ( e ( ie ) - e0 ) / ( e1 - e0 )) endif endif ! the logarithmic flux is always kept greater or equal zero. f ( ie ) = max ( f ( ie ), 0.0_wp ) enddo end subroutine trara1","tags":"","loc":"proc/trara1.html"},{"title":"core – radbelt","text":"Main module. See also https://ccmc.gsfc.nasa.gov/pub/modelweb/geomagnetic/igrf/fortran_code/bilcal.for https://ccmc.gsfc.nasa.gov/pub/modelweb/radiation_belt/radbelt/fortran_code/radbelt.for simple function version for testing Uses shellig_module radbelt_kinds_module trmfun_module module~~core~~UsesGraph module~core core module~radbelt_kinds_module radbelt_kinds_module module~core->module~radbelt_kinds_module module~shellig_module shellig_module module~core->module~shellig_module module~trmfun_module trmfun_module module~core->module~trmfun_module iso_fortran_env iso_fortran_env module~radbelt_kinds_module->iso_fortran_env module~shellig_module->module~radbelt_kinds_module module~trmfun_module->module~radbelt_kinds_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public :: radbelt_type the main class that can be used to get the flux. Components Type Visibility Attributes Name Initial type( trm_type ), private :: trm type( shellig_type ), private :: igrf Type-Bound Procedures procedure, public :: get_flux => get_flux_ procedure, public :: set_data_files_paths Functions public  function get_flux_ (me, lon, lat, height, year, e, imname) result(flux) Calculate the flux of trapped particles at a specific location and time. Arguments Type Intent Optional Attributes Name class( radbelt_type ), intent(inout) :: me real(kind=wp), intent(in) :: lon geodetic longitude in degrees (east) real(kind=wp), intent(in) :: lat geodetic latitude in degrees (north) real(kind=wp), intent(in) :: height altitude in km above sea level real(kind=wp), intent(in) :: year decimal year for which geomagnetic field is to\nbe calculated (e.g.:1995.5 for day 185 of 1995) real(kind=wp), intent(in) :: e minimum energy integer, intent(in) :: imname which method to use: Read more… Return Value real(kind=wp) The flux of particles above the given energy, in units of cm&#94;-2 s&#94;-1. public  function get_flux (lon, lat, height, year, e, imname) result(flux) Calculate the flux of trapped particles at a specific location and time.\n  This is just a function version of the class method from radbelt_type . Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: lon geodetic longitude in degrees (east) real(kind=wp), intent(in) :: lat geodetic latitude in degrees (north) real(kind=wp), intent(in) :: height altitude in km above sea level real(kind=wp), intent(in) :: year decimal year for which geomagnetic field is to\nbe calculated (e.g.:1995.5 for day 185 of 1995) real(kind=wp), intent(in) :: e minimum energy integer, intent(in) :: imname which method to use: Read more… Return Value real(kind=wp) The flux of particles above the given energy, in units of cm&#94;-2 s&#94;-1. Subroutines public  subroutine set_data_files_paths (me, aep8_dir, igrf_dir) Set the paths to the data files.\nIf not used or blank, the folder data/aep8 and data/igrf in the\ncurrent working directory is assumed Arguments Type Intent Optional Attributes Name class( radbelt_type ), intent(inout) :: me character(len=*), intent(in) :: aep8_dir character(len=*), intent(in) :: igrf_dir","tags":"","loc":"module/core.html"},{"title":"shellig_module – radbelt","text":"IGRF model History SHELLIG.FOR, Version 2.0, January 1992 11/01/91-DKB- SHELLG: lowest starting point for B0 search is 2 1/27/92-DKB- Adopted to IGRF-91 coefficients model 2/05/92-DKB- Reduce variable-names: INTER(P)SHC,EXTRA(P)SHC,INITI(ALI)ZE 8/08/95-DKB- Updated to IGRF-45-95; new coeff. DGRF90, IGRF95, IGRF95S 5/31/00-DKB- Updated to IGRF-45-00; new coeff.: IGRF00, IGRF00s 3/24/05-DKB- Updated to IGRF-45-10; new coeff.: IGRF05, IGRF05s Uses radbelt_kinds_module module~~shellig_module~~UsesGraph module~shellig_module shellig_module module~radbelt_kinds_module radbelt_kinds_module module~shellig_module->module~radbelt_kinds_module iso_fortran_env iso_fortran_env module~radbelt_kinds_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~shellig_module~~UsedByGraph module~shellig_module shellig_module module~core core module~core->module~shellig_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, private, parameter :: filename_len = 14 length of the model data file names real(kind=wp), private, parameter :: Era = 6371.2_wp earth radius for normalization of cartesian coordinates (6371.2 km) real(kind=wp), private, parameter :: erequ = 6378.16_wp real(kind=wp), private, parameter :: erpol = 6356.775_wp real(kind=wp), private, parameter :: Aquad = erequ*erequ square of major half axis for\nearth ellipsoid as recommended by international\nastronomical union real(kind=wp), private, parameter :: Bquad = erpol*erpol square of minor half axis for\nearth ellipsoid as recommended by international\nastronomical union real(kind=wp), private, parameter :: Umr = atan(1.0_wp)*4.0_wp/180.0_wp atan(1.0) 4./180. umr= real(kind=wp), private, parameter,               dimension(3,3) :: u = reshape([+0.3511737_wp, -0.9148385_wp, -0.1993679_wp, +0.9335804_wp, +0.3583680_wp, +0.0000000_wp, +0.0714471_wp, -0.1861260_wp, +0.9799247_wp], [3, 3]) Derived Types type, public :: shellig_type Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: igrf_dir directory containing the data files real(kind=wp), private, dimension(3) :: sp = 0.0_wp real(kind=wp), private, dimension(3) :: xi = 0.0_wp real(kind=wp), private, dimension(144) :: h = 0.0_wp Field model coefficients adjusted for shellg integer, private :: iyea = 0 the int year corresponding to the file name that has been read character(len=:), private, allocatable :: name file name integer, private :: nmax = 0 maximum order of spherical harmonics real(kind=wp), private :: Time = 0.0_wp year (decimal: 1973.5) for which magnetic field is to be calculated real(kind=wp), private, dimension(144) :: g = 0.0_wp g(m) -- normalized field coefficients (see feldcof ) m=nmax*(nmax+2) integer, private :: nmax1 = 0 saved variables from the file integer, private :: nmax2 = 0 saved variables from the file real(kind=wp), private, dimension(144) :: g_cache = 0.0_wp saved g from the file real(kind=wp), private :: step = 0.20_wp step size for field line tracing real(kind=wp), private :: steq = 0.03_wp step size for integration real(kind=wp), private, dimension(120) :: gh2 = 0.0_wp Type-Bound Procedures procedure, public :: igrf procedure, public :: feldcof procedure, public :: feldg procedure, public :: shellg procedure, public :: findb0 procedure, private :: extrashc procedure, private :: intershc procedure, private :: getshc procedure, private :: stoer procedure, public :: get_data_file_dir procedure, public :: set_data_file_dir Functions private  function get_data_file_dir (me) result(dir) Get the directory containing the data files. Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(in) :: me Return Value character(len=:), allocatable Subroutines private  subroutine set_data_file_dir (me, dir) Set the directory containing the data files. Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me character(len=*), intent(in) :: dir private  subroutine igrf (me, lon, lat, height, year, xl, bbx) Wrapper for IGRF functions. Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me real(kind=wp), intent(in) :: lon geodetic longitude in degrees (east) real(kind=wp), intent(in) :: lat geodetic latitude in degrees (north) real(kind=wp), intent(in) :: height altitude in km above sea level real(kind=wp), intent(in) :: year decimal year for which geomagnetic field is to\nbe calculated (e.g.:1995.5 for day 185 of 1995) real(kind=wp), intent(out) :: xl l-value real(kind=wp), intent(out) :: bbx b_total / b_equatorial ratio private  subroutine findb0 (me, stps, bdel, value, bequ, rr0) Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me real(kind=wp), intent(in) :: stps real(kind=wp), intent(inout) :: bdel logical, intent(out) :: value real(kind=wp), intent(out) :: bequ real(kind=wp), intent(out) :: rr0 private  subroutine shellg (me, glat, glon, alt, dimo, fl, icode, b0) calculates l-value for specified geodaetic coordinates, altitude\n  and gemagnetic field model. Read more… Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me real(kind=wp), intent(in) :: glat GEODETIC LATITUDE IN DEGREES (NORTH) real(kind=wp), intent(in) :: glon GEODETIC LONGITUDE IN DEGREES (EAST) real(kind=wp), intent(in) :: alt ALTITUDE IN KM ABOVE SEA LEVEL real(kind=wp), intent(in) :: dimo DIPOL MOMENT IN GAUSS (NORMALIZED TO EARTH RADIUS) real(kind=wp), intent(out) :: fl l-value integer, intent(out) :: icode Read more… real(kind=wp), intent(out) :: b0 magnetic field strength in gauss private  subroutine stoer (me, p, bq, r) subroutine used for field line tracing in shellg calls entry point feldi in geomagnetic field subroutine feldg Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me real(kind=wp), intent(inout), dimension(7) :: p real(kind=wp), intent(out) :: bq real(kind=wp), intent(out) :: r private  subroutine feldg (me, glat, glon, alt, bnorth, beast, bdown, Babs) Calculates earth magnetic field from spherical harmonics model Read more… Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me real(kind=wp), intent(in) :: glat geodetic latitude in degrees (north) real(kind=wp), intent(in) :: glon geodetic longitude in degrees (east) real(kind=wp), intent(in) :: alt altitude in km above sea level real(kind=wp), intent(out) :: bnorth components of the field with respect\nto the local geodetic coordinate system, with axis\npointing in the tangential plane to the north, east\nand downward. real(kind=wp), intent(out) :: beast components of the field with respect\nto the local geodetic coordinate system, with axis\npointing in the tangential plane to the north, east\nand downward. real(kind=wp), intent(out) :: bdown components of the field with respect\nto the local geodetic coordinate system, with axis\npointing in the tangential plane to the north, east\nand downward. real(kind=wp), intent(out) :: Babs magnetic field strength in gauss private  subroutine feldcof (me, year, dimo) Determines coefficients and dipol moment from IGRF models Read more… Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me real(kind=wp), intent(in) :: year decimal year for which geomagnetic field is to\nbe calculated (e.g.:1995.5 for day 185 of 1995) real(kind=wp), intent(out) :: dimo geomagnetic dipol moment in gauss (normalized\nto earth's radius) at the time (year) private  subroutine getshc (me, Fspec, Nmax, Erad, Gh, Ier) Reads spherical harmonic coefficients from the specified\n  file into an array. Read more… Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me character(len=*), intent(in) :: Fspec File specification integer, intent(out) :: Nmax Maximum degree and order of model real(kind=wp), intent(out) :: Erad Earth's radius associated with the spherical\nharmonic coefficients, in the same units as\nelevation real(kind=wp), intent(out), dimension(*) :: Gh Schmidt quasi-normal internal spherical\nharmonic coefficients integer, intent(out) :: Ier Error number: Read more… private  subroutine intershc (me, date, dte1, nmax1, gh1, dte2, nmax2, gh2, nmax, gh) Interpolates linearly, in time, between two spherical\n  harmonic models. Read more… Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me real(kind=wp), intent(in) :: date Date of resulting model (in decimal year) real(kind=wp), intent(in) :: dte1 Date of earlier model integer, intent(in) :: nmax1 Maximum degree and order of earlier model real(kind=wp), intent(in) :: gh1 (*) Schmidt quasi-normal internal spherical harmonic coefficients of earlier model real(kind=wp), intent(in) :: dte2 Date of later model integer, intent(in) :: nmax2 Maximum degree and order of later model real(kind=wp), intent(in) :: gh2 (*) Schmidt quasi-normal internal spherical harmonic coefficients of later model integer, intent(out) :: nmax Maximum degree and order of resulting model real(kind=wp), intent(out) :: gh (*) Coefficients of resulting model private  subroutine extrashc (me, date, dte1, nmax1, gh1, nmax2, gh2, nmax, gh) Extrapolates linearly a spherical harmonic model with a\n  rate-of-change model. Read more… Arguments Type Intent Optional Attributes Name class( shellig_type ), intent(inout) :: me real(kind=wp), intent(in) :: date Date of resulting model (in decimal year) real(kind=wp), intent(in) :: dte1 Date of base model integer, intent(in) :: nmax1 Maximum degree and order of base model real(kind=wp), intent(in) :: gh1 (*) Schmidt quasi-normal internal spherical harmonic coefficients of base model integer, intent(in) :: nmax2 Maximum degree and order of rate-of-change model real(kind=wp), intent(in) :: gh2 (*) Schmidt quasi-normal internal spherical harmonic coefficients of rate-of-change model integer, intent(out) :: nmax Maximum degree and order of resulting model real(kind=wp), intent(out) :: gh (*) Coefficients of resulting model","tags":"","loc":"module/shellig_module.html"},{"title":"trmfun_module – radbelt","text":"Trapped radiation model. History Based on: trmfun.for 1987 Uses radbelt_kinds_module module~~trmfun_module~~UsesGraph module~trmfun_module trmfun_module module~radbelt_kinds_module radbelt_kinds_module module~trmfun_module->module~radbelt_kinds_module iso_fortran_env iso_fortran_env module~radbelt_kinds_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~trmfun_module~~UsedByGraph module~trmfun_module trmfun_module module~core core module~core->module~trmfun_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial character(len=10), private, parameter,               dimension(4) :: mname = ['ae8min.asc', 'ae8max.asc', 'ap8min.asc', 'ap8max.asc'] data files available Derived Types type, public :: trm_type main class for the aep8 model Components Type Visibility Attributes Name Initial character(len=:), private, allocatable :: aep8_dir directory containing the data files character(len=:), private, allocatable :: file_loaded the file that has been loaded integer, private, dimension(8) :: ihead = 0 integer, private, dimension(:), allocatable :: map real(kind=wp), private :: fistep = 0.0_wp the stepsize for the parameterization of the logarithm of flux.\nformerly stored in common block tra2 real(kind=wp), private :: f1 = 1.001_wp real(kind=wp), private :: f2 = 1.002_wp Type-Bound Procedures procedure, public :: aep8 ../../ main routine procedure, public :: trara2 ../../ low-level routine procedure, public :: trara1 procedure, public :: get_data_file_dir procedure, public :: set_data_file_dir Functions private  function get_data_file_dir (me) result(dir) Get the directory containing the data files. Arguments Type Intent Optional Attributes Name class( trm_type ), intent(in) :: me Return Value character(len=:), allocatable private  function trara2 (me, map, il, ib) trara2 interpolates linearly in l-b/b0-map to obtain\n  the logarithm of integral flux at given l and b/b0. Read more… Arguments Type Intent Optional Attributes Name class( trm_type ), intent(inout) :: me integer, intent(in) :: map (*) is sub-map (for specific energy) of\ntrapped radiation model map integer, intent(in) :: il scaled l-value integer, intent(in) :: ib scaled b/b0-1 Return Value real(kind=wp) scaled logarithm of particle flux Subroutines private  subroutine set_data_file_dir (me, dir) Set the directory containing the data files. Arguments Type Intent Optional Attributes Name class( trm_type ), intent(inout) :: me character(len=*), intent(in) :: dir private  subroutine aep8 (me, e, l, bb0, imname, flux) Main wrapper for the radiation model.\nReads the coefficient file and calls the low-level routine. Arguments Type Intent Optional Attributes Name class( trm_type ), intent(inout) :: me real(kind=wp), intent(in) :: e real(kind=wp), intent(in) :: l real(kind=wp), intent(in) :: bb0 integer, intent(in) :: imname which model to load (index in mname array) real(kind=wp), intent(out) :: flux private  subroutine trara1 (me, descr, map, fl, bb0, e, f, n) trara1 finds particle fluxes for given energies, magnetic field\nstrength and l-value. function trara2 is used to interpolate in\nb-l-space. Arguments Type Intent Optional Attributes Name class( trm_type ), intent(inout) :: me integer, intent(in) :: descr (8) header of specified trapped radition model integer, intent(in) :: map (*) map of trapped radition model\n(descr and map are explained at the begin\nof the main program model) real(kind=wp), intent(in) :: fl l-value real(kind=wp), intent(in) :: bb0 =b/b0  magnetic field strength normalized\nto field strength at magnetic equator real(kind=wp), intent(in) :: e (n) array of energies in mev real(kind=wp), intent(out) :: f (n) decadic logarithm of integral fluxes in\nparticles/(cm cm sec) integer, intent(in) :: n number of energies","tags":"","loc":"module/trmfun_module.html"},{"title":"radbelt_kinds_module – radbelt","text":"Numeric kind definitions for radbelt. Uses iso_fortran_env module~~radbelt_kinds_module~~UsesGraph module~radbelt_kinds_module radbelt_kinds_module iso_fortran_env iso_fortran_env module~radbelt_kinds_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~radbelt_kinds_module~~UsedByGraph module~radbelt_kinds_module radbelt_kinds_module module~core core module~core->module~radbelt_kinds_module module~shellig_module shellig_module module~core->module~shellig_module module~trmfun_module trmfun_module module~core->module~trmfun_module module~shellig_module->module~radbelt_kinds_module module~trmfun_module->module~radbelt_kinds_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: wp = real64 Real working precision if not specified [8 bytes] integer, public, parameter :: ip = int32 Integer working precision if not specified [4 bytes]","tags":"","loc":"module/radbelt_kinds_module.html"},{"title":"core.f90 – radbelt","text":"This file depends on sourcefile~~core.f90~~EfferentGraph sourcefile~core.f90 core.f90 sourcefile~radbelt_kinds_module.f90 radbelt_kinds_module.F90 sourcefile~core.f90->sourcefile~radbelt_kinds_module.f90 sourcefile~shellig.f90 shellig.f90 sourcefile~core.f90->sourcefile~shellig.f90 sourcefile~trmfun.f90 trmfun.f90 sourcefile~core.f90->sourcefile~trmfun.f90 sourcefile~shellig.f90->sourcefile~radbelt_kinds_module.f90 sourcefile~trmfun.f90->sourcefile~radbelt_kinds_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> !  Main module. ! !### See also !   * https://ccmc.gsfc.nasa.gov/pub/modelweb/geomagnetic/igrf/fortran_code/bilcal.for !   * https://ccmc.gsfc.nasa.gov/pub/modelweb/radiation_belt/radbelt/fortran_code/radbelt.for module core use radbelt_kinds_module use trmfun_module use shellig_module implicit none type , public :: radbelt_type !! the main class that can be used to get the flux. private type ( trm_type ) :: trm type ( shellig_type ) :: igrf contains private procedure , public :: get_flux => get_flux_ procedure , public :: set_data_files_paths end type radbelt_type public :: get_flux !! simple function version for testing contains !***************************************************************************************** !> !  Set the paths to the data files. !  If not used or blank, the folder `data/aep8` and `data/igrf` in the !  current working directory is assumed subroutine set_data_files_paths ( me , aep8_dir , igrf_dir ) class ( radbelt_type ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: aep8_dir character ( len =* ), intent ( in ) :: igrf_dir call me % trm % set_data_file_dir ( trim ( aep8_dir )) call me % igrf % set_data_file_dir ( trim ( igrf_dir )) end subroutine set_data_files_paths !***************************************************************************************** !***************************************************************************************** !> !  Calculate the flux of trapped particles at a specific location and time. function get_flux_ ( me , lon , lat , height , year , e , imname ) result ( flux ) class ( radbelt_type ), intent ( inout ) :: me real ( wp ), intent ( in ) :: lon !! geodetic longitude in degrees (east) real ( wp ), intent ( in ) :: lat !! geodetic latitude in degrees (north) real ( wp ), intent ( in ) :: height !! altitude in km above sea level real ( wp ), intent ( in ) :: year !! decimal year for which geomagnetic field is to !! be calculated (e.g.:1995.5 for day 185 of 1995) real ( wp ), intent ( in ) :: e !! minimum energy integer , intent ( in ) :: imname !! which method to use: !! !! * 1 -- particle species: electrons, solar activity: min !! * 2 -- particle species: electrons, solar activity: max !! * 3 -- particle species: protons, solar activity: min !! * 4 -- particle species: protons, solar activity: max real ( wp ) :: flux !! The flux of particles above the given energy, in units of cm&#94;-2 s&#94;-1. real ( wp ) :: xl !! l value real ( wp ) :: bbx call me % igrf % igrf ( lon , lat , height , year , xl , bbx ) call me % trm % aep8 ( e , xl , bbx , imname , flux ) end function get_flux_ !***************************************************************************************** !***************************************************************************************** !> !  Calculate the flux of trapped particles at a specific location and time. !  This is just a function version of the class method from [[radbelt_type]]. ! !@note This routine is not efficient at all since it will reload all the !      files every time it is called. function get_flux ( lon , lat , height , year , e , imname ) result ( flux ) real ( wp ), intent ( in ) :: lon !! geodetic longitude in degrees (east) real ( wp ), intent ( in ) :: lat !! geodetic latitude in degrees (north) real ( wp ), intent ( in ) :: height !! altitude in km above sea level real ( wp ), intent ( in ) :: year !! decimal year for which geomagnetic field is to !! be calculated (e.g.:1995.5 for day 185 of 1995) real ( wp ), intent ( in ) :: e !! minimum energy integer , intent ( in ) :: imname !! which method to use: !! !! * 1 -- particle species: electrons, solar activity: min !! * 2 -- particle species: electrons, solar activity: max !! * 3 -- particle species: protons, solar activity: min !! * 4 -- particle species: protons, solar activity: max real ( wp ) :: flux !! The flux of particles above the given energy, in units of cm&#94;-2 s&#94;-1. type ( radbelt_type ) :: radbelt flux = radbelt % get_flux ( lon , lat , height , year , e , imname ) end function get_flux !***************************************************************************************** end module core","tags":"","loc":"sourcefile/core.f90.html"},{"title":"shellig.f90 – radbelt","text":"This file depends on sourcefile~~shellig.f90~~EfferentGraph sourcefile~shellig.f90 shellig.f90 sourcefile~radbelt_kinds_module.f90 radbelt_kinds_module.F90 sourcefile~shellig.f90->sourcefile~radbelt_kinds_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~shellig.f90~~AfferentGraph sourcefile~shellig.f90 shellig.f90 sourcefile~core.f90 core.f90 sourcefile~core.f90->sourcefile~shellig.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> !  IGRF model ! !### History !  * SHELLIG.FOR, Version 2.0, January 1992 !  * 11/01/91-DKB- SHELLG: lowest starting point for B0 search is 2 !  * 1/27/92-DKB- Adopted to IGRF-91 coefficients model !  * 2/05/92-DKB- Reduce variable-names: INTER(P)SHC,EXTRA(P)SHC,INITI(ALI)ZE !  * 8/08/95-DKB- Updated to IGRF-45-95; new coeff. DGRF90, IGRF95, IGRF95S !  * 5/31/00-DKB- Updated to IGRF-45-00; new coeff.: IGRF00, IGRF00s !  * 3/24/05-DKB- Updated to IGRF-45-10; new coeff.: IGRF05, IGRF05s module shellig_module use radbelt_kinds_module implicit none private integer , parameter :: filename_len = 14 !! length of the model data file names ! parameters formerly in `gener` common block real ( wp ), parameter :: Era = 637 1.2_wp !! earth radius for normalization of cartesian coordinates (6371.2 km) real ( wp ), parameter :: erequ = 637 8.16_wp real ( wp ), parameter :: erpol = 635 6.775_wp real ( wp ), parameter :: Aquad = erequ * erequ !! square of major half axis for !! earth ellipsoid as recommended by international !! astronomical union real ( wp ), parameter :: Bquad = erpol * erpol !! square of minor half axis for !! earth ellipsoid as recommended by international !! astronomical union real ( wp ), parameter :: Umr = atan ( 1.0_wp ) * 4.0_wp / 18 0.0_wp !! atan(1.0)*4./180.   <degree>*umr=<radiant> real ( wp ), dimension ( 3 , 3 ), parameter :: u = reshape ([ + 0.3511737_wp , - 0.9148385_wp , - 0.1993679_wp , & + 0.9335804_wp , + 0.3583680_wp , + 0.0000000_wp , & + 0.0714471_wp , - 0.1861260_wp , + 0.9799247_wp ], [ 3 , 3 ]) type , public :: shellig_type private character ( len = :), allocatable :: igrf_dir !! directory containing the data files ! formerly in the `fidb0` common block real ( wp ), dimension ( 3 ) :: sp = 0.0_wp ! formerly in blank common real ( wp ), dimension ( 3 ) :: xi = 0.0_wp real ( wp ), dimension ( 144 ) :: h = 0.0_wp !! Field model coefficients adjusted for [[shellg]] ! formerly in `model` common block integer :: iyea = 0 !! the int year corresponding to the file `name` that has been read character ( len = :), allocatable :: name !! file name integer :: nmax = 0 !! maximum order of spherical harmonics real ( wp ) :: Time = 0.0_wp !! year (decimal: 1973.5) for which magnetic field is to be calculated real ( wp ), dimension ( 144 ) :: g = 0.0_wp !! `g(m)` -- normalized field coefficients (see [[feldcof]]) m=nmax*(nmax+2) integer :: nmax1 = 0 !! saved variables from the file integer :: nmax2 = 0 !! saved variables from the file real ( wp ), dimension ( 144 ) :: g_cache = 0.0_wp !! saved `g` from the file ! formerly saved vars in shellg: real ( wp ) :: step = 0.20_wp !! step size for field line tracing real ( wp ) :: steq = 0.03_wp !! step size for integration ! from feldcof, so we can cache the coefficients real ( wp ), dimension ( 120 ) :: gh2 = 0.0_wp ! JW : why is this 120 and g is 144 ??? contains private procedure , public :: igrf procedure , public :: feldcof procedure , public :: feldg procedure , public :: shellg procedure , public :: findb0 procedure :: stoer , getshc , intershc , extrashc procedure , public :: set_data_file_dir , get_data_file_dir end type shellig_type contains !***************************************************************************************** !***************************************************************************************** !> !  Set the directory containing the data files. subroutine set_data_file_dir ( me , dir ) class ( shellig_type ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: dir me % igrf_dir = trim ( dir ) end subroutine set_data_file_dir !***************************************************************************************** !> !  Get the directory containing the data files. function get_data_file_dir ( me ) result ( dir ) class ( shellig_type ), intent ( in ) :: me character ( len = :), allocatable :: dir if ( allocated ( me % igrf_dir )) then dir = trim ( me % igrf_dir ) // '/' else dir = 'data/igrf/' ! default end if end function get_data_file_dir !***************************************************************************************** !> !  Wrapper for IGRF functions. subroutine igrf ( me , lon , lat , height , year , xl , bbx ) class ( shellig_type ), intent ( inout ) :: me real ( wp ), intent ( in ) :: lon !! geodetic longitude in degrees (east) real ( wp ), intent ( in ) :: lat !! geodetic latitude in degrees (north) real ( wp ), intent ( in ) :: height !! altitude in km above sea level real ( wp ), intent ( in ) :: year !! decimal year for which geomagnetic field is to !! be calculated (e.g.:1995.5 for day 185 of 1995) real ( wp ), intent ( out ) :: xl !! l-value real ( wp ), intent ( out ) :: bbx !! b_total / b_equatorial ratio real ( wp ) :: bab1 , babs , bdel , bdown , beast , & beq , bequ , bnorth , dimo , rr0 integer :: icode logical :: val real ( wp ), parameter :: stps = 0.05_wp ! JW : do we need to reset some or all of these ? me % sp = 0.0_wp me % xi = 0.0_wp me % h = 0.0_wp me % step = 0.20_wp me % steq = 0.03_wp call me % feldcof ( year , dimo ) call me % feldg ( lat , lon , height , bnorth , beast , bdown , babs ) call me % shellg ( lat , lon , height , dimo , xl , icode , bab1 ) bequ = dimo / ( xl * xl * xl ) if ( icode == 1 ) then bdel = 1.0e-3_wp call me % findb0 ( stps , bdel , val , beq , rr0 ) if ( val ) bequ = beq endif bbx = babs / bequ end subroutine igrf !***************************************************************************************** !***************************************************************************************** !> subroutine findb0 ( me , stps , bdel , value , bequ , rr0 ) class ( shellig_type ), intent ( inout ) :: me real ( wp ), intent ( in ) :: stps real ( wp ), intent ( inout ) :: bdel real ( wp ), intent ( out ) :: bequ logical , intent ( out ) :: value real ( wp ), intent ( out ) :: rr0 real ( wp ) :: b , bdelta , bmin , bold , bq1 , & bq2 , bq3 , p ( 8 , 4 ) , r1 , r2 , r3 , & rold , step , step12 , zz integer :: i , irun , j , n step = stps irun = 0 main : do irun = irun + 1 if ( irun > 5 ) then value = . false . exit main endif !*********************first three points p ( 1 , 2 ) = me % sp ( 1 ) p ( 2 , 2 ) = me % sp ( 2 ) p ( 3 , 2 ) = me % sp ( 3 ) step =- sign ( step , p ( 3 , 2 )) call me % stoer ( p ( 1 , 2 ), bq2 , r2 ) p ( 1 , 3 ) = p ( 1 , 2 ) + 0.5_wp * step * p ( 4 , 2 ) p ( 2 , 3 ) = p ( 2 , 2 ) + 0.5_wp * step * p ( 5 , 2 ) p ( 3 , 3 ) = p ( 3 , 2 ) + 0.5_wp * step call me % stoer ( p ( 1 , 3 ), bq3 , r3 ) p ( 1 , 1 ) = p ( 1 , 2 ) - step * ( 2.0_wp * p ( 4 , 2 ) - p ( 4 , 3 )) p ( 2 , 1 ) = p ( 2 , 2 ) - step * ( 2.0_wp * p ( 5 , 2 ) - p ( 5 , 3 )) p ( 3 , 1 ) = p ( 3 , 2 ) - step call me % stoer ( p ( 1 , 1 ), bq1 , r1 ) p ( 1 , 3 ) = p ( 1 , 2 ) + step * ( 2 0.0_wp * p ( 4 , 3 ) - 3. * p ( 4 , 2 ) + p ( 4 , 1 )) / 1 8.0_wp p ( 2 , 3 ) = p ( 2 , 2 ) + step * ( 2 0.0_wp * p ( 5 , 3 ) - 3. * p ( 5 , 2 ) + p ( 5 , 1 )) / 1 8.0_wp p ( 3 , 3 ) = p ( 3 , 2 ) + step call me % stoer ( p ( 1 , 3 ), bq3 , r3 ) !******************invert sense if required if ( bq3 > bq1 ) then step =- step r3 = r1 bq3 = bq1 do i = 1 , 5 zz = p ( i , 1 ) p ( i , 1 ) = p ( i , 3 ) p ( i , 3 ) = zz end do end if !******************initialization step12 = step / 1 2.0_wp value = . true . bmin = 1.0e4_wp bold = 1.0e4_wp !******************corrector (field line tracing) n = 0 corrector : do p ( 1 , 3 ) = p ( 1 , 2 ) + step12 * ( 5.0_wp * p ( 4 , 3 ) + 8.0_wp * p ( 4 , 2 ) - p ( 4 , 1 )) n = n + 1 p ( 2 , 3 ) = p ( 2 , 2 ) + step12 * ( 5.0_wp * p ( 5 , 3 ) + 8.0_wp * p ( 5 , 2 ) - p ( 5 , 1 )) !******************predictor (field line tracing) p ( 1 , 4 ) = p ( 1 , 3 ) + step12 * ( 2 3.0_wp * p ( 4 , 3 ) - 1 6.0_wp * p ( 4 , 2 ) + 5.0_wp * p ( 4 , 1 )) p ( 2 , 4 ) = p ( 2 , 3 ) + step12 * ( 2 3.0_wp * p ( 5 , 3 ) - 1 6.0_wp * p ( 5 , 2 ) + 5.0_wp * p ( 5 , 1 )) p ( 3 , 4 ) = p ( 3 , 3 ) + step call me % stoer ( p ( 1 , 4 ), bq3 , r3 ) do j = 1 , 3 do i = 1 , 8 p ( i , j ) = p ( i , j + 1 ) end do end do b = sqrt ( bq3 ) if ( b < bmin ) bmin = b if ( b > bold ) exit corrector bold = b rold = 1.0_wp / r3 me % sp ( 1 ) = p ( 1 , 4 ) me % sp ( 2 ) = p ( 2 , 4 ) me % sp ( 3 ) = p ( 3 , 4 ) end do corrector if ( bold /= bmin ) value = . false . bdelta = ( b - bold ) / bold if ( bdelta <= bdel ) exit main step = step / 1 0.0_wp end do main rr0 = rold bequ = bold bdel = bdelta end subroutine findb0 !***************************************************************************************** !> !  calculates l-value for specified geodaetic coordinates, altitude !  and gemagnetic field model. ! !### Reference !  * G. KLUGE, EUROPEAN SPACE OPERATIONS CENTER, INTERNAL NOTE !    NO. 67, 1970. !  * G. KLUGE, COMPUTER PHYSICS COMMUNICATIONS 3, 31-35, 1972 ! !### History ! * CHANGES (D. BILITZA, NOV 87): !   - USING CORRECT DIPOL MOMENT I.E.,DIFFERENT COMMON/MODEL/ !   - USING IGRF EARTH MAGNETIC FIELD MODELS FROM 1945 TO 1990 subroutine shellg ( me , glat , glon , alt , dimo , fl , icode , b0 ) class ( shellig_type ), intent ( inout ) :: me real ( wp ), intent ( in ) :: glat !! GEODETIC LATITUDE IN DEGREES (NORTH) real ( wp ), intent ( in ) :: glon !! GEODETIC LONGITUDE IN DEGREES (EAST) real ( wp ), intent ( in ) :: alt !! ALTITUDE IN KM ABOVE SEA LEVEL real ( wp ), intent ( in ) :: dimo !! DIPOL MOMENT IN GAUSS (NORMALIZED TO EARTH RADIUS) real ( wp ), intent ( out ) :: fl !! l-value integer , intent ( out ) :: icode !! * =1 normal completion !! * =2 unphysical conjugate point (fl meaningless) !! * =3 shell parameter greater than limit up to !!   which accurate calculation is required; !!   approximation is used. real ( wp ), intent ( out ) :: b0 !! magnetic field strength in gauss real ( wp ) :: arg1 , arg2 , bequ , bq1 , bq2 , bq3 , c0 , c1 , c2 , c3 , & ct , d , d0 , d1 , d2 , dimob0 , e0 , e1 , e2 , ff , fi , gg , & hli , oradik , oterm , p ( 8 , 100 ) , r , r1 , r2 , r3 , r3h , radik , & rlat , rlon , rq , st , step12 , step2 , & stp , t , term , v ( 3 ) , xx , z , zq , zz integer :: i , iequ , n real ( wp ), parameter :: rmin = 0.05_wp !! boundaries for identification of `icode=2 and 3` real ( wp ), parameter :: rmax = 1.01_wp !! boundaries for identification of `icode=2 and 3` bequ = 1.0e10_wp !*****ENTRY POINT SHELLG TO BE USED WITH GEODETIC CO-ORDINATES rlat = Glat * Umr ct = sin ( rlat ) st = cos ( rlat ) d = sqrt ( Aquad - ( Aquad - Bquad ) * ct * ct ) me % Xi ( 1 ) = ( Alt + Aquad / d ) * st / Era me % Xi ( 3 ) = ( Alt + Bquad / d ) * ct / Era rlon = Glon * Umr me % Xi ( 2 ) = me % Xi ( 1 ) * sin ( rlon ) me % Xi ( 1 ) = me % Xi ( 1 ) * cos ( rlon ) CALL spag_block_1 () RETURN !*****ENTRY POINT SHELLC TO BE USED WITH CARTESIAN CO-ORDINATES   ! JW : does not appear to be used anywhere. !    V(3)  CARTESIAN COORDINATES IN EARTH RADII (6371.2 KM) !      X-AXIS POINTING TO EQUATOR AT 0 LONGITUDE !      Y-AXIS POINTING TO EQUATOR AT 90 LONG. !      Z-AXIS POINTING TO NORTH POLE ENTRY shellc ( me , V , Fl , B0 ) me % Xi ( 1 ) = V ( 1 ) me % Xi ( 2 ) = V ( 2 ) me % Xi ( 3 ) = V ( 3 ) CALL spag_block_1 () CONTAINS subroutine spag_block_1 integer , parameter :: max_loop_index = 100 ! 3333   <--- JW : original code had 3333 ... was this a bug ???? !*****CONVERT TO DIPOL-ORIENTED CO-ORDINATES rq = 1.0_wp / ( me % Xi ( 1 ) * me % Xi ( 1 ) + me % Xi ( 2 ) * me % Xi ( 2 ) + me % Xi ( 3 ) * me % Xi ( 3 )) r3h = sqrt ( rq * sqrt ( rq )) p ( 1 , 2 ) = ( me % Xi ( 1 ) * u ( 1 , 1 ) + me % Xi ( 2 ) * u ( 2 , 1 ) + me % Xi ( 3 ) * u ( 3 , 1 )) * r3h p ( 2 , 2 ) = ( me % Xi ( 1 ) * u ( 1 , 2 ) + me % Xi ( 2 ) * u ( 2 , 2 )) * r3h p ( 3 , 2 ) = ( me % Xi ( 1 ) * u ( 1 , 3 ) + me % Xi ( 2 ) * u ( 2 , 3 ) + me % Xi ( 3 ) * u ( 3 , 3 )) * rq !     *****FIRST THREE POINTS OF FIELD LINE me % step = - sign ( me % step , p ( 3 , 2 )) call me % stoer ( p ( 1 , 2 ), bq2 , r2 ) B0 = sqrt ( bq2 ) p ( 1 , 3 ) = p ( 1 , 2 ) + 0.5_wp * me % step * p ( 4 , 2 ) p ( 2 , 3 ) = p ( 2 , 2 ) + 0.5_wp * me % step * p ( 5 , 2 ) p ( 3 , 3 ) = p ( 3 , 2 ) + 0.5_wp * me % step call me % stoer ( p ( 1 , 3 ), bq3 , r3 ) p ( 1 , 1 ) = p ( 1 , 2 ) - me % step * ( 2.0_wp * p ( 4 , 2 ) - p ( 4 , 3 )) p ( 2 , 1 ) = p ( 2 , 2 ) - me % step * ( 2.0_wp * p ( 5 , 2 ) - p ( 5 , 3 )) p ( 3 , 1 ) = p ( 3 , 2 ) - me % step call me % stoer ( p ( 1 , 1 ), bq1 , r1 ) p ( 1 , 3 ) = p ( 1 , 2 ) + me % step * ( 2 0.0_wp * p ( 4 , 3 ) - 3. * p ( 4 , 2 ) + p ( 4 , 1 )) / 1 8.0_wp p ( 2 , 3 ) = p ( 2 , 2 ) + me % step * ( 2 0.0_wp * p ( 5 , 3 ) - 3. * p ( 5 , 2 ) + p ( 5 , 1 )) / 1 8.0_wp p ( 3 , 3 ) = p ( 3 , 2 ) + me % step call me % stoer ( p ( 1 , 3 ), bq3 , r3 ) !*****INVERT SENSE IF REQUIRED IF ( bq3 > bq1 ) THEN me % step = - me % step r3 = r1 bq3 = bq1 DO i = 1 , 7 zz = p ( i , 1 ) p ( i , 1 ) = p ( i , 3 ) p ( i , 3 ) = zz ENDDO ENDIF !*****SEARCH FOR LOWEST MAGNETIC FIELD STRENGTH IF ( bq1 < bequ ) THEN bequ = bq1 iequ = 1 ENDIF IF ( bq2 < bequ ) THEN bequ = bq2 iequ = 2 ENDIF IF ( bq3 < bequ ) THEN bequ = bq3 iequ = 3 ENDIF !*****INITIALIZATION OF INTEGRATION LOOPS step12 = me % step / 1 2.0_wp step2 = me % step + me % step me % steq = sign ( me % steq , me % step ) fi = 0.0_wp Icode = 1 oradik = 0.0_wp oterm = 0.0_wp stp = r2 * me % steq z = p ( 3 , 2 ) + stp stp = stp / 0.75_wp p ( 8 , 1 ) = step2 * ( p ( 1 , 1 ) * p ( 4 , 1 ) + p ( 2 , 1 ) * p ( 5 , 1 )) p ( 8 , 2 ) = step2 * ( p ( 1 , 2 ) * p ( 4 , 2 ) + p ( 2 , 2 ) * p ( 5 , 2 )) !*****MAIN LOOP (FIELD LINE TRACING) main : DO n = 3 , max_loop_index !*****CORRECTOR (FIELD LINE TRACING) p ( 1 , n ) = p ( 1 , n - 1 ) + step12 * ( 5.0_wp * p ( 4 , n ) + 8.0_wp * p ( 4 , n - 1 ) - p ( 4 , n - 2 )) p ( 2 , n ) = p ( 2 , n - 1 ) + step12 * ( 5.0_wp * p ( 5 , n ) + 8.0_wp * p ( 5 , n - 1 ) - p ( 5 , n - 2 )) !*****PREPARE EXPANSION COEFFICIENTS FOR INTERPOLATION !*****OF SLOWLY VARYING QUANTITIES p ( 8 , n ) = step2 * ( p ( 1 , n ) * p ( 4 , n ) + p ( 2 , n ) * p ( 5 , n )) c0 = p ( 1 , n - 1 ) ** 2 + p ( 2 , n - 1 ) ** 2 c1 = p ( 8 , n - 1 ) c2 = ( p ( 8 , n ) - p ( 8 , n - 2 )) * 0.25_wp c3 = ( p ( 8 , n ) + p ( 8 , n - 2 ) - c1 - c1 ) / 6.0_wp d0 = p ( 6 , n - 1 ) d1 = ( p ( 6 , n ) - p ( 6 , n - 2 )) * 0.5_wp d2 = ( p ( 6 , n ) + p ( 6 , n - 2 ) - d0 - d0 ) * 0.5_wp e0 = p ( 7 , n - 1 ) e1 = ( p ( 7 , n ) - p ( 7 , n - 2 )) * 0.5_wp e2 = ( p ( 7 , n ) + p ( 7 , n - 2 ) - e0 - e0 ) * 0.5_wp inner : DO !*****INNER LOOP (FOR QUADRATURE) t = ( z - p ( 3 , n - 1 )) / me % step IF ( t > 1.0_wp ) THEN !*****PREDICTOR (FIELD LINE TRACING) p ( 1 , n + 1 ) = p ( 1 , n ) + step12 * ( 2 3.0_wp * p ( 4 , n ) - 1 6.0_wp * p ( 4 , n - 1 ) + 5.0_wp * p ( 4 , n - 2 )) p ( 2 , n + 1 ) = p ( 2 , n ) + step12 * ( 2 3.0_wp * p ( 5 , n ) - 1 6.0_wp * p ( 5 , n - 1 ) + 5.0_wp * p ( 5 , n - 2 )) p ( 3 , n + 1 ) = p ( 3 , n ) + me % step call me % stoer ( p ( 1 , n + 1 ), bq3 , r3 ) !*****SEARCH FOR LOWEST MAGNETIC FIELD STRENGTH IF ( bq3 < bequ ) THEN iequ = n + 1 bequ = bq3 ENDIF EXIT inner ELSE hli = 0.5_wp * ((( c3 * t + c2 ) * t + c1 ) * t + c0 ) zq = z * z r = hli + sqrt ( hli * hli + zq ) IF ( r <= rmin ) THEN !*****APPROXIMATION FOR HIGH VALUES OF L. Icode = 3 t = - p ( 3 , n - 1 ) / me % step Fl = 1.0_wp / ( abs ((( c3 * t + c2 ) * t + c1 ) * t + c0 ) + 1.0e-15_wp ) RETURN ENDIF rq = r * r ff = sqrt ( 1.0_wp + 3.0_wp * zq / rq ) radik = B0 - (( d2 * t + d1 ) * t + d0 ) * r * rq * ff IF ( r > rmax ) THEN Icode = 2 radik = radik - 1 2.0_wp * ( r - rmax ) ** 2 ENDIF IF ( radik + radik <= oradik ) EXIT main term = sqrt ( radik ) * ff * (( e2 * t + e1 ) * t + e0 ) / ( rq + zq ) fi = fi + stp * ( oterm + term ) oradik = radik oterm = term stp = r * me % steq z = z + stp ENDIF ENDDO inner ENDDO main IF ( iequ < 2 ) iequ = 2 me % Sp ( 1 ) = p ( 1 , iequ - 1 ) me % Sp ( 2 ) = p ( 2 , iequ - 1 ) me % Sp ( 3 ) = p ( 3 , iequ - 1 ) IF ( oradik >= 1.0e-15_wp ) fi = fi + stp / 0.75_wp * oterm * oradik / ( oradik - radik ) ! !-- The minimal allowable value of FI was changed from 1E-15 to 1E-12, !-- because 1E-38 is the minimal allowable arg. for ALOG in our envir. !-- D. Bilitza, Nov 87. ! fi = 0.5_wp * abs ( fi ) / sqrt ( B0 ) + 1.0e-12_wp !*****COMPUTE L FROM B AND I.  SAME AS CARMEL IN INVAR. ! !-- Correct dipole moment is used here. D. Bilitza, Nov 87. ! dimob0 = Dimo / B0 arg1 = log ( fi ) arg2 = log ( dimob0 ) !       arg = FI*FI*FI/DIMOB0 !       if(abs(arg)>88.0_wp) arg=88.0_wp xx = 3 * arg1 - arg2 IF ( xx > 2 3.0_wp ) THEN gg = xx - 3.0460681_wp ELSEIF ( xx > 1 1.7_wp ) THEN gg = ((((( 2.8212095E-8_wp * xx - 3.8049276E-6_wp ) * xx + & 2.170224E-4_wp ) * xx - 6.7310339E-3_wp ) * xx + & 1.2038224E-1_wp ) * xx - 1.8461796E-1_wp ) * xx + 2.0007187_wp ELSEIF ( xx >+ 3.0_wp ) THEN gg = (((((((( 6.3271665E-10_wp * xx - 3.958306E-8_wp ) * xx + & 9.9766148E-07_wp ) * xx - 1.2531932E-5_wp ) * xx + & 7.9451313E-5_wp ) * xx - 3.2077032E-4_wp ) * xx + & 2.1680398E-3_wp ) * xx + 1.2817956E-2_wp ) * xx + & 4.3510529E-1_wp ) * xx + 6.222355E-1_wp ELSEIF ( xx >- 3.0_wp ) THEN gg = (((((((( 2.6047023E-10_wp * xx + 2.3028767E-9_wp ) * xx - & 2.1997983E-8_wp ) * xx - 5.3977642E-7_wp ) * xx - & 3.3408822E-6_wp ) * xx + 3.8379917E-5_wp ) * xx + & 1.1784234E-3_wp ) * xx + 1.4492441E-2_wp ) * xx + & 4.3352788E-1_wp ) * xx + 6.228644E-1_wp ELSEIF ( xx >- 2 2.0_wp ) THEN gg = (((((((( - 8.1537735E-14_wp * xx + 8.3232531E-13_wp ) * xx + & 1.0066362E-9_wp ) * xx + 8.1048663E-8_wp ) * xx + & 3.2916354E-6_wp ) * xx + 8.2711096E-5_wp ) * xx + & 1.3714667E-3_wp ) * xx + 1.5017245E-2_wp ) * xx + & 4.3432642E-1_wp ) * xx + 6.2337691E-1_wp ELSE gg = 3.33338E-1_wp * xx + 3.0062102E-1_wp ENDIF Fl = exp ( log (( 1.0_wp + exp ( gg )) * dimob0 ) / 3.0_wp ) RETURN END subroutine spag_block_1 END subroutine shellg !***************************************************************************************** !> !  subroutine used for field line tracing in [[shellg]] !  calls entry point [[feldi]] in geomagnetic field subroutine [[feldg]] subroutine stoer ( me , p , bq , r ) class ( shellig_type ), intent ( inout ) :: me real ( wp ), dimension ( 7 ), intent ( inout ) :: p real ( wp ), intent ( out ) :: bq real ( wp ), intent ( out ) :: r real ( wp ) :: dr , dsq , dx , dxm , dy , dym , dz , & dzm , fli , q , rq , wr , xm , ym , zm !*****XM,YM,ZM ARE GEOMAGNETIC CARTESIAN INVERSE CO-ORDINATES zm = P ( 3 ) fli = P ( 1 ) * P ( 1 ) + P ( 2 ) * P ( 2 ) + 1.0e-15_wp R = 0.5_wp * ( fli + sqrt ( fli * fli + ( zm + zm ) ** 2 )) rq = R * R wr = sqrt ( R ) xm = P ( 1 ) * wr ym = P ( 2 ) * wr !*****TRANSFORM TO GEOGRAPHIC CO-ORDINATE SYSTEM me % Xi ( 1 ) = xm * u ( 1 , 1 ) + ym * u ( 1 , 2 ) + zm * u ( 1 , 3 ) me % Xi ( 2 ) = xm * u ( 2 , 1 ) + ym * u ( 2 , 2 ) + zm * u ( 2 , 3 ) me % Xi ( 3 ) = xm * u ( 3 , 1 ) + zm * u ( 3 , 3 ) !*****COMPUTE DERIVATIVES ! Changed from CALL FELDI(XI,H); XI, H are in COMMON block; results ! are the same; dkb Feb 1998. ! JW : feb 2024 : xi, h now class variables. CALL feldi ( me ) q = me % H ( 1 ) / rq dx = me % H ( 3 ) + me % H ( 3 ) + q * me % Xi ( 1 ) dy = me % H ( 4 ) + me % H ( 4 ) + q * me % Xi ( 2 ) dz = me % H ( 2 ) + me % H ( 2 ) + q * me % Xi ( 3 ) !*****TRANSFORM BACK TO GEOMAGNETIC CO-ORDINATE SYSTEM dxm = u ( 1 , 1 ) * dx + u ( 2 , 1 ) * dy + u ( 3 , 1 ) * dz dym = u ( 1 , 2 ) * dx + u ( 2 , 2 ) * dy dzm = u ( 1 , 3 ) * dx + u ( 2 , 3 ) * dy + u ( 3 , 3 ) * dz dr = ( xm * dxm + ym * dym + zm * dzm ) / R !*****FORM SLOWLY VARYING EXPRESSIONS P ( 4 ) = ( wr * dxm - 0.5_wp * P ( 1 ) * dr ) / ( R * dzm ) P ( 5 ) = ( wr * dym - 0.5_wp * P ( 2 ) * dr ) / ( R * dzm ) dsq = rq * ( dxm * dxm + dym * dym + dzm * dzm ) Bq = dsq * rq * rq P ( 6 ) = sqrt ( dsq / ( rq + 3.0_wp * zm * zm )) P ( 7 ) = P ( 6 ) * ( rq + zm * zm ) / ( rq * dzm ) END subroutine stoer !***************************************************************************************** !> !  Calculates earth magnetic field from spherical harmonics model ! !### Reference ! ref: g. kluge, european space operations centre, internal note 61, !      1970. ! !### History !  * changes (d. bilitza, nov 87): !   - field coefficients in binary data files instead of block data !   - calculates dipol moment subroutine feldg ( me , glat , glon , alt , bnorth , beast , bdown , babs ) class ( shellig_type ), intent ( inout ) :: me real ( wp ), intent ( in ) :: glat !! geodetic latitude in degrees (north) real ( wp ), intent ( in ) :: glon !! geodetic longitude in degrees (east) real ( wp ), intent ( in ) :: alt !! altitude in km above sea level real ( wp ), intent ( out ) :: bnorth , beast , bdown !! components of the field with respect !! to the local geodetic coordinate system, with axis !! pointing in the tangential plane to the north, east !! and downward. real ( wp ), intent ( out ) :: Babs !! magnetic field strength in gauss real ( wp ) :: b ( 3 ) , brho , bxxx , & byyy , bzzz , cp , ct , d , f , rho , & rlat , rlon , rq , s , sp , st , t , v ( 3 ) , x , xxx , & y , yyy , z , zzz integer :: i , ih , ihmax , il , imax , is , k , last , m !-- is records entry point ! !*****entry point  feldg  to be used with geodetic co-ordinates is = 1 rlat = glat * umr ct = sin ( rlat ) st = cos ( rlat ) d = sqrt ( aquad - ( aquad - bquad ) * ct * ct ) rlon = glon * umr cp = cos ( rlon ) sp = sin ( rlon ) zzz = ( alt + bquad / d ) * ct / era rho = ( alt + aquad / d ) * st / era xxx = rho * cp yyy = rho * sp goto 10 !*****entry point  feldc  to be used with cartesian co-ordinates !        v(3)  cartesian coordinates in earth radii (6371.2 km) !            x-axis pointing to equator at 0 longitude !            y-axis pointing to equator at 90 long. !            z-axis pointing to north pole entry feldc ( me , v , b ) is = 2 xxx = v ( 1 ) yyy = v ( 2 ) zzz = v ( 3 ) 10 rq = 1.0_wp / ( xxx * xxx + yyy * yyy + zzz * zzz ) me % xi ( 1 ) = xxx * rq me % xi ( 2 ) = yyy * rq me % xi ( 3 ) = zzz * rq goto 20 !*****entry point  feldi  used for l computation entry feldi ( me ) is = 3 20 ihmax = me % nmax * me % nmax + 1 last = ihmax + me % nmax + me % nmax imax = me % nmax + me % nmax - 1 do i = ihmax , last me % h ( i ) = me % g ( i ) end do do k = 1 , 3 , 2 i = imax ih = ihmax do il = ih - i f = 2.0_wp / real ( i - k + 2 , wp ) x = me % xi ( 1 ) * f y = me % xi ( 2 ) * f z = me % xi ( 3 ) * ( f + f ) i = i - 2 if (( i - 1 ) >= 0 ) then if (( i - 1 ) > 0 ) then do m = 3 , i , 2 me % h ( il + m + 1 ) = me % g ( il + m + 1 ) + z * me % h ( ih + m + 1 ) + x * ( me % h ( ih + m + 3 ) - & me % h ( ih + m - 1 )) - y * ( me % h ( ih + m + 2 ) + me % h ( ih + m - 2 )) me % h ( il + m ) = me % g ( il + m ) + z * me % h ( ih + m ) + x * ( me % h ( ih + m + 2 ) - & me % h ( ih + m - 2 )) + y * ( me % h ( ih + m + 3 ) + me % h ( ih + m - 1 )) end do end if me % h ( il + 2 ) = me % g ( il + 2 ) + z * me % h ( ih + 2 ) + x * me % h ( ih + 4 ) - y * ( me % h ( ih + 3 ) + me % h ( ih )) me % h ( il + 1 ) = me % g ( il + 1 ) + z * me % h ( ih + 1 ) + y * me % h ( ih + 4 ) + x * ( me % h ( ih + 3 ) - me % h ( ih )) end if me % h ( il ) = me % g ( il ) + z * me % h ( ih ) + 2.0_wp * ( x * me % h ( ih + 1 ) + y * me % h ( ih + 2 )) ih = il if ( i < k ) exit end do end do if ( is == 3 ) return s = 0.5_wp * me % h ( 1 ) + 2.0_wp * ( me % h ( 2 ) * me % xi ( 3 ) + me % h ( 3 ) * me % xi ( 1 ) + me % h ( 4 ) * me % xi ( 2 )) t = ( rq + rq ) * sqrt ( rq ) bxxx = t * ( me % h ( 3 ) - s * xxx ) byyy = t * ( me % h ( 4 ) - s * yyy ) bzzz = t * ( me % h ( 2 ) - s * zzz ) if ( is == 2 ) then b ( 1 ) = bxxx b ( 2 ) = byyy b ( 3 ) = bzzz else babs = sqrt ( bxxx * bxxx + byyy * byyy + bzzz * bzzz ) beast = byyy * cp - bxxx * sp brho = byyy * sp + bxxx * cp bnorth = bzzz * st - brho * ct bdown =- bzzz * ct - brho * st end if end subroutine feldg !***************************************************************************************** !> !  Determines coefficients and dipol moment from IGRF models ! !### Author !  * D. BILITZA, NSSDC, GSFC, CODE 633, GREENBELT, MD 20771, !    (301) 286-9536 NOV 1987. ! !### History !  * corrected for 2000 update - dkb- 5/31/2000 !  * updated to IGRF-2000 version -dkb- 5/31/2000 !  * updated to IGRF-2005 version -dkb- 3/24/2000 subroutine feldcof ( me , year , dimo ) class ( shellig_type ), intent ( inout ) :: me real ( wp ), intent ( in ) :: year !! decimal year for which geomagnetic field is to !! be calculated (e.g.:1995.5 for day 185 of 1995) real ( wp ), intent ( out ) :: dimo !! geomagnetic dipol moment in gauss (normalized !! to earth's radius) at the time (year) real ( wp ) :: dte1 , dte2 , erad , gha ( 144 ) , sqrt2 integer :: i , ier , j , l , m , n , iyea character ( len = :), allocatable :: fil2 real ( wp ) :: x , f0 , f !! these were double precision in original !! code while everything else was single precision ! changed to conform with IGRF 45-95, also FILMOD, DTEMOD arrays +1 character ( len = filename_len ), dimension ( 17 ), parameter :: filmod = [& 'dgrf1945.dat ' , 'dgrf1950.dat ' , 'dgrf1955.dat ' , 'dgrf1960.dat ' , & 'dgrf1965.dat ' , 'dgrf1970.dat ' , 'dgrf1975.dat ' , 'dgrf1980.dat ' , & 'dgrf1985.dat ' , 'dgrf1990.dat ' , 'dgrf1995.dat ' , 'dgrf2000.dat ' , & 'dgrf2005.dat ' , 'dgrf2010.dat ' , 'dgrf2015.dat ' , 'igrf2020.dat ' , & 'igrf2020s.dat' ] real ( wp ), dimension ( 17 ), parameter :: dtemod = [ 194 5.0_wp , 195 0.0_wp , 195 5.0_wp , & 196 0.0_wp , 196 5.0_wp , 197 0.0_wp , & 197 5.0_wp , 198 0.0_wp , 198 5.0_wp , & 199 0.0_wp , 199 5.0_wp , 200 0.0_wp , & 200 5.0_wp , 201 0.0_wp , 201 5.0_wp , & 202 0.0_wp , 202 5.0_wp ] integer , parameter :: numye = size ( dtemod ) - 1 ! number of 5-year priods represented by IGRF integer , parameter :: is = 0 !! * is=0 for schmidt normalization !! * is=1 gauss normalization logical :: read_file !-- determine igrf-years for input-year me % time = year iyea = int ( year / 5.0_wp ) * 5 read_file = iyea /= me % iyea ! if we have to read the file me % iyea = iyea l = ( me % iyea - 1945 ) / 5 + 1 if ( l < 1 ) l = 1 if ( l > numye ) l = numye dte1 = dtemod ( l ) me % name = me % get_data_file_dir () // trim ( filmod ( l )) dte2 = dtemod ( l + 1 ) fil2 = me % get_data_file_dir () // trim ( filmod ( l + 1 )) if ( read_file ) then ! get igrf coefficients for the boundary years ! [if they have not ready been loaded] call me % getshc ( me % name , me % nmax1 , erad , me % g , ier ) if ( ier /= 0 ) error stop 'error reading file: ' // trim ( me % name ) me % g_cache = me % g ! because it is modified below, we have to cache the original values from the file call me % getshc ( fil2 , me % nmax2 , erad , me % gh2 , ier ) if ( ier /= 0 ) error stop 'error reading file: ' // trim ( fil2 ) else me % g = me % g_cache end if !-- determine igrf coefficients for year if ( l <= numye - 1 ) then call me % intershc ( year , dte1 , me % nmax1 , me % g , dte2 , me % nmax2 , me % gh2 , me % nmax , gha ) else call me % extrashc ( year , dte1 , me % nmax1 , me % g , me % nmax2 , me % gh2 , me % nmax , gha ) endif !-- determine magnetic dipol moment and coeffiecients g f0 = 0.0_wp do j = 1 , 3 f = gha ( j ) * 1.0e-5_wp f0 = f0 + f * f enddo dimo = sqrt ( f0 ) me % g ( 1 ) = 0.0_wp i = 2 f0 = 1.0e-5_wp if ( is == 0 ) f0 = - f0 sqrt2 = sqrt ( 2.0_wp ) do n = 1 , me % nmax x = n f0 = f0 * x * x / ( 4.0_wp * x - 2.0_wp ) if ( is == 0 ) f0 = f0 * ( 2.0_wp * x - 1.0_wp ) / x f = f0 * 0.5_wp if ( is == 0 ) f = f * sqrt2 me % g ( i ) = gha ( i - 1 ) * f0 i = i + 1 do m = 1 , n f = f * ( x + m ) / ( x - m + 1.0_wp ) if ( is == 0 ) f = f * sqrt (( x - m + 1.0_wp ) / ( x + m )) me % g ( i ) = gha ( i - 1 ) * f me % g ( i + 1 ) = gha ( i ) * f i = i + 2 enddo enddo end subroutine feldcof !***************************************************************************************** !> !  Reads spherical harmonic coefficients from the specified !  file into an array. ! !### Author !  * Version 1.01, A. Zunde, USGS, MS 964, !    Box 25046 Federal Center, Denver, CO  80225 subroutine getshc ( me , Fspec , Nmax , Erad , Gh , Ier ) class ( shellig_type ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: Fspec !! File specification integer , intent ( out ) :: Nmax !! Maximum degree and order of model real ( wp ), intent ( out ) :: Erad !! Earth's radius associated with the spherical !! harmonic coefficients, in the same units as !! elevation real ( wp ), dimension ( * ), intent ( out ) :: Gh !! Schmidt quasi-normal internal spherical !! harmonic coefficients integer , intent ( out ) :: Ier !! Error number: !! !!  * 0, no error !!  * -2, records out of order !!  * FORTRAN run-time error number integer :: iu !! logical unit number real ( wp ) :: g , h integer :: i , m , mm , n , nn read_file : block ! --------------------------------------------------------------- !  Open coefficient file. Read past first header record. !  Read degree and order of model and Earth's radius. ! --------------------------------------------------------------- OPEN ( newunit = Iu , FILE = Fspec , STATUS = 'OLD' , IOSTAT = Ier ) if ( Ier /= 0 ) then write ( * , * ) 'Error opening file: ' // trim ( fspec ) exit read_file end if READ ( Iu , * , IOSTAT = Ier ) if ( Ier /= 0 ) exit read_file READ ( Iu , * , IOSTAT = Ier ) Nmax , Erad if ( Ier /= 0 ) exit read_file ! --------------------------------------------------------------- !  Read the coefficient file, arranged as follows: ! !          N     M     G     H !          ---------------------- !            /   1     0    GH(1)  - !           /  1     1    GH(2) GH(3) !          /  2     0    GH(4)  - !         /  2     1    GH(5) GH(6) !      NMAX*(NMAX+3)/2   /  2     2    GH(7) GH(8) !         records    \\  3     0    GH(9)  - !         \\      .     .     .     . !          \\  .     .     .     . !      NMAX*(NMAX+2)     \\  .     .     .     . !      elements in GH      \\  NMAX  NMAX   .     . ! !  N and M are, respectively, the degree and order of the !  coefficient. ! --------------------------------------------------------------- i = 0 main : DO nn = 1 , Nmax DO mm = 0 , nn READ ( Iu , * , IOSTAT = Ier ) n , m , g , h if ( Ier /= 0 ) exit main IF ( nn /= n . OR . mm /= m ) THEN Ier = - 2 EXIT main ENDIF i = i + 1 Gh ( i ) = g IF ( m /= 0 ) THEN i = i + 1 Gh ( i ) = h ENDIF ENDDO ENDDO main end block read_file CLOSE ( Iu ) END subroutine getshc !***************************************************************************************** !> !  Interpolates linearly, in time, between two spherical !  harmonic models. ! !  The coefficients (GH) of the resulting model, at date !  DATE, are computed by linearly interpolating between the !  coefficients of the earlier model (GH1), at date DTE1, !  and those of the later model (GH2), at date DTE2. If one !  model is smaller than the other, the interpolation is !  performed with the missing coefficients assumed to be 0. ! !### Author !  * Version 1.01, A. Zunde !    USGS, MS 964, Box 25046 Federal Center, Denver, CO  80225 subroutine intershc ( me , date , dte1 , nmax1 , gh1 , dte2 , nmax2 , gh2 , nmax , gh ) class ( shellig_type ), intent ( inout ) :: me real ( wp ), intent ( in ) :: date !! Date of resulting model (in decimal year) real ( wp ), intent ( in ) :: dte1 !! Date of earlier model integer , intent ( in ) :: nmax1 !! Maximum degree and order of earlier model real ( wp ), intent ( in ) :: gh1 ( * ) !! Schmidt quasi-normal internal spherical harmonic coefficients of earlier model real ( wp ), intent ( in ) :: dte2 !! Date of later model integer , intent ( in ) :: nmax2 !! Maximum degree and order of later model real ( wp ), intent ( in ) :: gh2 ( * ) !! Schmidt quasi-normal internal spherical harmonic coefficients of later model real ( wp ), intent ( out ) :: gh ( * ) !! Coefficients of resulting model integer , intent ( out ) :: nmax !! Maximum degree and order of resulting model real ( wp ) :: factor integer :: i , k , l factor = ( date - dte1 ) / ( dte2 - dte1 ) if ( nmax1 == nmax2 ) then k = nmax1 * ( nmax1 + 2 ) nmax = nmax1 elseif ( nmax1 > nmax2 ) then k = nmax2 * ( nmax2 + 2 ) l = nmax1 * ( nmax1 + 2 ) do i = k + 1 , l gh ( i ) = gh1 ( i ) + factor * ( - gh1 ( i )) enddo nmax = nmax1 else k = nmax1 * ( nmax1 + 2 ) l = nmax2 * ( nmax2 + 2 ) do i = k + 1 , l gh ( i ) = factor * gh2 ( i ) enddo nmax = nmax2 endif do i = 1 , k gh ( i ) = gh1 ( i ) + factor * ( gh2 ( i ) - gh1 ( i )) enddo end subroutine intershc !***************************************************************************************** !> !  Extrapolates linearly a spherical harmonic model with a !  rate-of-change model. ! !  The coefficients (GH) of the resulting model, at date !  DATE, are computed by linearly extrapolating the coef- !  ficients of the base model (GH1), at date DTE1, using !  those of the rate-of-change model (GH2), at date DTE2. If !  one model is smaller than the other, the extrapolation is !  performed with the missing coefficients assumed to be 0. ! !### Author !  * Version 1.01, A. Zunde !    USGS, MS 964, Box 25046 Federal Center, Denver, CO  80225 subroutine extrashc ( me , date , dte1 , nmax1 , gh1 , nmax2 , gh2 , nmax , gh ) class ( shellig_type ), intent ( inout ) :: me real ( wp ), intent ( in ) :: date !! Date of resulting model (in decimal year) real ( wp ), intent ( in ) :: dte1 !! Date of base model integer , intent ( in ) :: nmax1 !! Maximum degree and order of base model real ( wp ), intent ( in ) :: gh1 ( * ) !! Schmidt quasi-normal internal spherical harmonic coefficients of base model integer , intent ( in ) :: nmax2 !! Maximum degree and order of rate-of-change model real ( wp ), intent ( in ) :: gh2 ( * ) !! Schmidt quasi-normal internal spherical harmonic coefficients of rate-of-change model real ( wp ), intent ( out ) :: gh ( * ) !! Coefficients of resulting model integer , intent ( out ) :: nmax !! Maximum degree and order of resulting model real ( wp ) :: factor integer :: i , k , l factor = ( date - dte1 ) if ( nmax1 == nmax2 ) then k = nmax1 * ( nmax1 + 2 ) nmax = nmax1 elseif ( nmax1 > nmax2 ) then k = nmax2 * ( nmax2 + 2 ) l = nmax1 * ( nmax1 + 2 ) do i = k + 1 , l gh ( i ) = gh1 ( i ) enddo nmax = nmax1 else k = nmax1 * ( nmax1 + 2 ) l = nmax2 * ( nmax2 + 2 ) do i = k + 1 , l gh ( i ) = factor * gh2 ( i ) enddo nmax = nmax2 endif do i = 1 , k gh ( i ) = gh1 ( i ) + factor * gh2 ( i ) enddo end subroutine extrashc end module SHELLIG_module","tags":"","loc":"sourcefile/shellig.f90.html"},{"title":"trmfun.f90 – radbelt","text":"This file depends on sourcefile~~trmfun.f90~~EfferentGraph sourcefile~trmfun.f90 trmfun.f90 sourcefile~radbelt_kinds_module.f90 radbelt_kinds_module.F90 sourcefile~trmfun.f90->sourcefile~radbelt_kinds_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~trmfun.f90~~AfferentGraph sourcefile~trmfun.f90 trmfun.f90 sourcefile~core.f90 core.f90 sourcefile~core.f90->sourcefile~trmfun.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> !  Trapped radiation model. ! !### History !  * Based on: `trmfun.for` 1987 module trmfun_module use radbelt_kinds_module implicit none private character ( len = 10 ), dimension ( 4 ), parameter :: mname = [ 'ae8min.asc' , & 'ae8max.asc' , & 'ap8min.asc' , & 'ap8max.asc' ] !! data files available type , public :: trm_type !! main class for the `aep8` model private character ( len = :), allocatable :: aep8_dir !! directory containing the data files ! data read from the files: character ( len = :), allocatable :: file_loaded !! the file that has been loaded integer , dimension ( 8 ) :: ihead = 0 integer , dimension (:), allocatable :: map real ( wp ) :: fistep = 0.0_wp !! the stepsize for the parameterization of the logarithm of flux. !! formerly stored in common block `tra2` ! formerly saved variables in trara1: real ( wp ) :: f1 = 1.001_wp real ( wp ) :: f2 = 1.002_wp contains private procedure , public :: aep8 !! main routine procedure , public :: trara1 , trara2 !! low-level routine procedure , public :: set_data_file_dir , get_data_file_dir end type trm_type contains !***************************************************************************************** !> !  Set the directory containing the data files. subroutine set_data_file_dir ( me , dir ) class ( trm_type ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: dir me % aep8_dir = trim ( dir ) end subroutine set_data_file_dir !***************************************************************************************** !> !  Get the directory containing the data files. function get_data_file_dir ( me ) result ( dir ) class ( trm_type ), intent ( in ) :: me character ( len = :), allocatable :: dir if ( allocated ( me % aep8_dir )) then dir = trim ( me % aep8_dir ) // '/' else dir = 'data/aep8/' ! default end if end function get_data_file_dir !***************************************************************************************** !> !  Main wrapper for the radiation model. !  Reads the coefficient file and calls the low-level routine. subroutine aep8 ( me , e , l , bb0 , imname , flux ) class ( trm_type ), intent ( inout ) :: me real ( wp ), intent ( in ) :: e real ( wp ), intent ( in ) :: l real ( wp ), intent ( in ) :: bb0 integer , intent ( in ) :: imname !! which model to load (index in `mname` array) real ( wp ), intent ( out ) :: flux real ( wp ) :: ee ( 1 ), f ( 1 ) !! temp variables integer :: i , ierr , iuaeap , nmap character ( len = :), allocatable :: name logical :: load_file name = me % get_data_file_dir () // trim ( mname ( Imname )) ! the file to load ! JW : do we need to reset some or all of these ? me % fistep = 0.0_wp me % f1 = 1.001_wp me % f2 = 1.002_wp ! check to see if this file has already been loaded ! [the class can store one file at a time] load_file = . true . if ( allocated ( me % file_loaded )) then if ( name == me % file_loaded ) load_file = . false . end if if ( load_file ) then open ( newunit = iuaeap , file = name , status = 'OLD' , iostat = ierr , form = 'FORMATTED' ) if ( ierr /= 0 ) then error stop 'error reading ' // trim ( name ) end if read ( iuaeap , '(1X,12I6)' ) me % ihead nmap = me % ihead ( 8 ) allocate ( me % map ( nmap )) read ( iuaeap , '(1X,12I6)' ) ( me % map ( i ), i = 1 , nmap ) close ( iuaeap ) me % file_loaded = trim ( name ) end if ee ( 1 ) = e call me % trara1 ( me % ihead , me % map , L , Bb0 , ee , f , 1 ) flux = f ( 1 ) IF ( Flux > 0.0_wp ) Flux = 1 0.0_wp ** Flux end subroutine aep8 !***************************************************************************************** !***************************************************************************************** !> !  [[trara1]] finds particle fluxes for given energies, magnetic field !  strength and l-value. function [[trara2]] is used to interpolate in !  b-l-space. subroutine trara1 ( me , descr , map , fl , bb0 , e , f , n ) class ( trm_type ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of energies integer , intent ( in ) :: descr ( 8 ) !! header of specified trapped radition model real ( wp ), intent ( in ) :: e ( n ) !! array of energies in mev real ( wp ), intent ( in ) :: fl !! l-value real ( wp ), intent ( in ) :: bb0 !! =b/b0  magnetic field strength normalized !! to field strength at magnetic equator integer , intent ( in ) :: map ( * ) !! map of trapped radition model !! (descr and map are explained at the begin !! of the main program model) real ( wp ), intent ( out ) :: f ( n ) !! decadic logarithm of integral fluxes in !! particles/(cm*cm*sec) real ( wp ) :: e0 , e1 , e2 , escale , f0 , fscale , xnl real ( wp ) :: bb0_ !! local copy of `bb0`. in the original code !! this was modified by this routine. !! added this so `bb0` could be `intent(in)` integer :: i0 , i1 , i2 , i3 , ie , l3 , nb , nl logical :: s0 , s1 , s2 bb0_ = bb0 me % fistep = descr ( 7 ) / descr ( 2 ) escale = descr ( 4 ) fscale = descr ( 7 ) xnl = min ( 1 5.6_wp , abs ( fl )) nl = xnl * descr ( 5 ) if ( bb0_ < 1.0_wp ) bb0_ = 1.0_wp nb = ( bb0_ - 1.0_wp ) * descr ( 6 ) ! i2 is the number of elements in the flux map for the first energy. ! i3 is the index of the last element of the second energy map. ! l3 is the length of the map for the third energy. ! e1 is the energy of the first energy map (unscaled) ! e2 is the energy of the second energy map (unscaled) i1 = 0 i2 = map ( 1 ) i3 = i2 + map ( i2 + 1 ) l3 = map ( i3 + 1 ) e1 = map ( i1 + 2 ) / escale e2 = map ( i2 + 2 ) / escale ! s0, s1, s2 are logical variables which indicate whether the flux for ! a particular e, b, l point has already been found in a previous call ! to function trara2. if not, s.. =.true. s1 = . true . s2 = . true . ! energy loop do ie = 1 , n ! for each energy e(i) find the successive energies e0,e1,e2 in ! model map, which obey  e0 < e1 < e(i) < e2 . do while ( ( e ( ie ) > e2 ) . and . ( l3 /= 0 ) ) i0 = i1 i1 = i2 i2 = i3 i3 = i3 + l3 l3 = map ( i3 + 1 ) e0 = e1 e1 = e2 e2 = map ( i2 + 2 ) / escale s0 = s1 s1 = s2 s2 = . true . f0 = me % f1 me % f1 = me % f2 enddo ! call trara2 to interpolate the flux-maps for e1,e2 in l-b/b0- ! space to find fluxes f1,f2 [if they have not already been ! calculated for a previous e(i)]. if ( s1 ) me % f1 = me % trara2 ( map ( i1 + 3 ), nl , nb ) / fscale if ( s2 ) me % f2 = me % trara2 ( map ( i2 + 3 ), nl , nb ) / fscale s1 = . false . s2 = . false . ! finally, interpolate in energy. f ( ie ) = me % f1 + ( me % f2 - me % f1 ) * ( e ( ie ) - e1 ) / ( e2 - e1 ) if ( me % f2 <= 0.0_wp ) then if ( i1 /= 0 ) then ! --------- special interpolation --------------------------------- ! if the flux for the second energy cannot be found (i.e. f2=0.0), ! and the zeroth energy map has been defined (i.e. i1 not equal 0), ! then interpolate using the flux maps for the zeroth and first ! energy and choose the minimum of this interpolations and the ! interpolation that was done with f2=0. if ( s0 ) f0 = me % trara2 ( map ( i0 + 3 ), nl , nb ) / fscale s0 = . false . f ( ie ) = min ( f ( ie ), f0 + ( me % f1 - f0 ) * ( e ( ie ) - e0 ) / ( e1 - e0 )) endif endif ! the logarithmic flux is always kept greater or equal zero. f ( ie ) = max ( f ( ie ), 0.0_wp ) enddo end subroutine trara1 !***************************************************************************************** !> !  [[trara2]] interpolates linearly in l-b/b0-map to obtain !  the logarithm of integral flux at given l and b/b0. ! !### Note !  see main program 'model' for explanation of map format !  scaling factors. function trara2 ( me , map , il , ib ) class ( trm_type ), intent ( inout ) :: me integer , intent ( in ) :: map ( * ) !! is sub-map (for specific energy) of !! trapped radiation model map integer , intent ( in ) :: il !! scaled l-value integer , intent ( in ) :: ib !! scaled b/b0-1 real ( wp ) :: trara2 !! scaled logarithm of particle flux real ( wp ) :: dfl , fincr1 , fincr2 , fistep , fkb , fkb1 , fkb2 , fkbj1 , fkbj2 , & fkbm , fll1 , fll2 , flog , flog1 , flog2 , flogm , & fnb , fnl , sl1 , sl2 integer :: i1 , i2 , itime , j1 , j2 , kt , l1 , l2 integer :: spag_nextblock_1 fistep = me % fistep spag_nextblock_1 = 1 main : do select case ( spag_nextblock_1 ) case ( 1 ) fnl = il fnb = ib itime = 0 i2 = 0 do ! find consecutive sub-sub-maps for scaled l-values ls1,ls2, ! with il less or equal ls2.  l1,l2 are lengths of sub-sub-maps. ! i1,i2 are indeces of first elements minus 1. l2 = map ( i2 + 1 ) if ( map ( i2 + 2 ) <= il ) then i1 = i2 l1 = l2 i2 = i2 + l2 ! if sub-sub-maps are empty, i. e. length less 4, than trara2=0 elseif ( ( l1 < 4 ) . and . ( l2 < 4 ) ) then trara2 = 0.0_wp return else ! if flog2 less flog1, than ls2 first map and ls1 second map if ( map ( i2 + 3 ) <= map ( i1 + 3 ) ) exit spag_nextblock_1 = 3 cycle main endif enddo spag_nextblock_1 = 2 case ( 2 ) kt = i1 i1 = i2 i2 = kt kt = l1 l1 = l2 l2 = kt spag_nextblock_1 = 3 case ( 3 ) ! determine interpolate in scaled l-value fll1 = map ( i1 + 2 ) fll2 = map ( i2 + 2 ) dfl = ( fnl - fll1 ) / ( fll2 - fll1 ) flog1 = map ( i1 + 3 ) flog2 = map ( i2 + 3 ) fkb1 = 0.0_wp fkb2 = 0.0_wp if ( l1 >= 4 ) then ! b/b0 loop do j2 = 4 , l2 fincr2 = map ( i2 + j2 ) if ( fkb2 + fincr2 > fnb ) goto 10 fkb2 = fkb2 + fincr2 flog2 = flog2 - fistep enddo itime = itime + 1 if ( itime == 1 ) then spag_nextblock_1 = 2 cycle main endif trara2 = 0.0_wp return 10 if ( itime /= 1 ) then if ( j2 == 4 ) then spag_nextblock_1 = 4 cycle main endif sl2 = flog2 / fkb2 do j1 = 4 , l1 fincr1 = map ( i1 + j1 ) fkb1 = fkb1 + fincr1 flog1 = flog1 - fistep fkbj1 = (( flog1 / fistep ) * fincr1 + fkb1 ) / (( fincr1 / fistep ) * sl2 + 1.0_wp ) if ( fkbj1 <= fkb1 ) goto 15 enddo if ( fkbj1 <= fkb2 ) then trara2 = 0.0_wp return endif 15 if ( fkbj1 <= fkb2 ) then fkbm = fkbj1 + ( fkb2 - fkbj1 ) * dfl flogm = fkbm * sl2 flog2 = flog2 - fistep fkb2 = fkb2 + fincr2 sl1 = flog1 / fkb1 sl2 = flog2 / fkb2 spag_nextblock_1 = 5 cycle main else fkb1 = 0.0_wp endif endif fkb2 = 0.0_wp endif j2 = 4 fincr2 = map ( i2 + j2 ) flog2 = map ( i2 + 3 ) flog1 = map ( i1 + 3 ) spag_nextblock_1 = 4 case ( 4 ) flogm = flog1 + ( flog2 - flog1 ) * dfl fkbm = 0.0_wp fkb2 = fkb2 + fincr2 flog2 = flog2 - fistep sl2 = flog2 / fkb2 if ( l1 < 4 ) then fincr1 = 0.0_wp sl1 = - 90000 0.0_wp spag_nextblock_1 = 6 cycle main else j1 = 4 fincr1 = map ( i1 + j1 ) fkb1 = fkb1 + fincr1 flog1 = flog1 - fistep sl1 = flog1 / fkb1 endif spag_nextblock_1 = 5 case ( 5 ) do while ( sl1 >= sl2 ) fkbj2 = (( flog2 / fistep ) * fincr2 + fkb2 ) / (( fincr2 / fistep ) * sl1 + 1.0_wp ) fkb = fkb1 + ( fkbj2 - fkb1 ) * dfl flog = fkb * sl1 if ( fkb >= fnb ) then spag_nextblock_1 = 7 cycle main endif fkbm = fkb flogm = flog if ( j1 >= l1 ) then trara2 = 0.0_wp return else j1 = j1 + 1 fincr1 = map ( i1 + j1 ) flog1 = flog1 - fistep fkb1 = fkb1 + fincr1 sl1 = flog1 / fkb1 endif enddo spag_nextblock_1 = 6 case ( 6 ) fkbj1 = (( flog1 / fistep ) * fincr1 + fkb1 ) / (( fincr1 / fistep ) * sl2 + 1.0_wp ) fkb = fkbj1 + ( fkb2 - fkbj1 ) * dfl flog = fkb * sl2 if ( fkb < fnb ) then fkbm = fkb flogm = flog if ( j2 >= l2 ) then trara2 = 0.0_wp return else j2 = j2 + 1 fincr2 = map ( i2 + j2 ) flog2 = flog2 - fistep fkb2 = fkb2 + fincr2 sl2 = flog2 / fkb2 spag_nextblock_1 = 5 cycle main endif endif spag_nextblock_1 = 7 case ( 7 ) if ( fkb < fkbm + 1.0e-10_wp ) then trara2 = 0.0_wp else trara2 = flogm + ( flog - flogm ) * (( fnb - fkbm ) / ( fkb - fkbm )) trara2 = max ( trara2 , 0.0_wp ) return endif exit main end select enddo main end function trara2 end module trmfun_module","tags":"","loc":"sourcefile/trmfun.f90.html"},{"title":"radbelt_kinds_module.F90 – radbelt","text":"Files dependent on this one sourcefile~~radbelt_kinds_module.f90~~AfferentGraph sourcefile~radbelt_kinds_module.f90 radbelt_kinds_module.F90 sourcefile~core.f90 core.f90 sourcefile~core.f90->sourcefile~radbelt_kinds_module.f90 sourcefile~shellig.f90 shellig.f90 sourcefile~core.f90->sourcefile~shellig.f90 sourcefile~trmfun.f90 trmfun.f90 sourcefile~core.f90->sourcefile~trmfun.f90 sourcefile~shellig.f90->sourcefile~radbelt_kinds_module.f90 sourcefile~trmfun.f90->sourcefile~radbelt_kinds_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> !  Numeric kind definitions for radbelt. module radbelt_kinds_module use , intrinsic :: iso_fortran_env implicit none private #ifdef REAL32 integer , parameter , public :: wp = real32 !! Real working precision [4 bytes] #elif REAL64 integer , parameter , public :: wp = real64 !! Real working precision [8 bytes] #elif REAL128 integer , parameter , public :: wp = real128 !! Real working precision [16 bytes] #else integer , parameter , public :: wp = real64 !! Real working precision if not specified [8 bytes] #endif #ifdef INT8 integer , parameter , public :: ip = int8 !! Integer working precision [1 byte] #elif INT16 integer , parameter , public :: ip = int16 !! Integer working precision [2 bytes] #elif INT32 integer , parameter , public :: ip = int32 !! Integer working precision [4 bytes] #elif INT64 integer , parameter , public :: ip = int64 !! Integer working precision [8 bytes] #else integer , parameter , public :: ip = int32 !! Integer working precision if not specified [4 bytes] #endif !***************************************************************************************** end module radbelt_kinds_module !*****************************************************************************************","tags":"","loc":"sourcefile/radbelt_kinds_module.f90.html"}]}